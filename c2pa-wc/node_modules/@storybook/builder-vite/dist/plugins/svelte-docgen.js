"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.svelteDocgen = void 0;
const magic_string_1 = __importDefault(require("magic-string"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const sveltedoc_parser_1 = __importDefault(require("sveltedoc-parser"));
const node_logger_1 = require("@storybook/node-logger");
const compiler_1 = require("svelte/compiler");
// Most of the code here should probably be exported by @storybook/svelte and reused here.
// See: https://github.com/storybookjs/storybook/blob/next/app/svelte/src/server/svelte-docgen-loader.ts
// From https://github.com/sveltejs/svelte/blob/8db3e8d0297e052556f0b6dde310ef6e197b8d18/src/compiler/compile/utils/get_name_from_filename.ts
// Copied because it is not exported from the compiler
function getNameFromFilename(filename) {
    var _a;
    if (!filename)
        return null;
    const parts = filename.split(/[/\\]/).map(encodeURI);
    if (parts.length > 1) {
        const index_match = parts[parts.length - 1].match(/^index(\.\w+)/);
        if (index_match) {
            parts.pop();
            parts[parts.length - 1] += index_match[1];
        }
    }
    const base = (_a = parts
        .pop()) === null || _a === void 0 ? void 0 : _a.replace(/%/g, 'u').replace(/\.[^.]+$/, '').replace(/[^a-zA-Z_$0-9]+/g, '_').replace(/^_/, '').replace(/_$/, '').replace(/^(\d)/, '_$1');
    if (!base) {
        throw new Error(`Could not derive component name from file ${filename}`);
    }
    return base[0].toUpperCase() + base.slice(1);
}
function svelteDocgen(svelteOptions) {
    const cwd = process.cwd();
    const { preprocess: preprocessOptions, logDocgen = false } = svelteOptions;
    return {
        name: 'svelte-docgen',
        async transform(src, id) {
            if (/\.(svelte)$/.test(id)) {
                const resource = path_1.default.relative(cwd, id);
                let docOptions;
                if (preprocessOptions) {
                    const src = fs_1.default.readFileSync(resource).toString();
                    const { code: fileContent } = await (0, compiler_1.preprocess)(src, preprocessOptions, { filename: resource });
                    docOptions = {
                        fileContent,
                    };
                }
                else {
                    docOptions = { filename: resource };
                }
                // set SvelteDoc options
                const options = {
                    ...docOptions,
                    version: 3,
                };
                const s = new magic_string_1.default(src);
                try {
                    const componentDoc = await sveltedoc_parser_1.default.parse(options);
                    // get filename for source content
                    const file = path_1.default.basename(resource);
                    componentDoc.name = path_1.default.basename(file);
                    const componentName = getNameFromFilename(resource);
                    s.append(`;${componentName}.__docgen = ${JSON.stringify(componentDoc)}`);
                }
                catch (error) {
                    if (logDocgen) {
                        node_logger_1.logger.error(error);
                    }
                }
                return {
                    code: s.toString(),
                    map: s.generateMap({ hires: true, source: id }),
                };
            }
        },
    };
}
exports.svelteDocgen = svelteDocgen;
//# sourceMappingURL=svelte-docgen.js.map