{"version":3,"file":"DeleteGlobsPlugin.js","sourceRoot":"","sources":["../../src/plugins/DeleteGlobsPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport glob from 'glob';\nimport { FileSystem, LegacyAdapters, Async } from '@rushstack/node-core-library';\n\nimport { HeftEventPluginBase } from '../pluginFramework/HeftEventPluginBase';\nimport { ScopedLogger } from '../pluginFramework/logging/ScopedLogger';\nimport { HeftSession } from '../pluginFramework/HeftSession';\nimport { HeftConfiguration } from '../configuration/HeftConfiguration';\nimport {\n  IHeftEventActions,\n  HeftEvent,\n  IHeftConfigurationDeleteGlobsEventAction\n} from '../utilities/CoreConfigFiles';\nimport { ICleanStageProperties } from '../stages/CleanStage';\nimport { IBuildStageProperties } from '../stages/BuildStage';\nimport { Constants } from '../utilities/Constants';\n\nconst globEscape: (unescaped: string) => string = require('glob-escape'); // No @types/glob-escape package exists\n\nexport class DeleteGlobsPlugin extends HeftEventPluginBase<IHeftConfigurationDeleteGlobsEventAction> {\n  public readonly pluginName: string = 'DeleteGlobsPlugin';\n  protected eventActionName: keyof IHeftEventActions = 'deleteGlobs';\n  protected loggerName: string = 'delete-globs';\n\n  /**\n   * @override\n   */\n  protected async handleCleanEventActionsAsync(\n    heftEvent: HeftEvent,\n    heftEventActions: IHeftConfigurationDeleteGlobsEventAction[],\n    logger: ScopedLogger,\n    heftSession: HeftSession,\n    heftConfiguration: HeftConfiguration,\n    properties: ICleanStageProperties\n  ): Promise<void> {\n    await this._runDeleteForHeftEventActions(\n      heftEventActions,\n      logger,\n      heftConfiguration,\n      properties.pathsToDelete\n    );\n  }\n\n  /**\n   * @override\n   */\n  protected async handleBuildEventActionsAsync(\n    heftEvent: HeftEvent,\n    heftEventActions: IHeftConfigurationDeleteGlobsEventAction[],\n    logger: ScopedLogger,\n    heftSession: HeftSession,\n    heftConfiguration: HeftConfiguration,\n    properties: IBuildStageProperties\n  ): Promise<void> {\n    await this._runDeleteForHeftEventActions(heftEventActions, logger, heftConfiguration);\n  }\n\n  private async _runDeleteForHeftEventActions(\n    heftEventActions: IHeftConfigurationDeleteGlobsEventAction[],\n    logger: ScopedLogger,\n    heftConfiguration: HeftConfiguration,\n    additionalPathsToDelete?: Set<string>\n  ): Promise<void> {\n    let deletedFiles: number = 0;\n    let deletedFolders: number = 0;\n\n    const pathsToDelete: Set<string> = new Set<string>(additionalPathsToDelete);\n    for (const deleteGlobsEventAction of heftEventActions) {\n      for (const globPattern of deleteGlobsEventAction.globsToDelete) {\n        const resolvedPaths: string[] = await this._resolvePathAsync(\n          globPattern,\n          heftConfiguration.buildFolder\n        );\n        for (const resolvedPath of resolvedPaths) {\n          pathsToDelete.add(resolvedPath);\n        }\n      }\n    }\n\n    await Async.forEachAsync(\n      pathsToDelete,\n      async (pathToDelete) => {\n        try {\n          FileSystem.deleteFile(pathToDelete, { throwIfNotExists: true });\n          logger.terminal.writeVerboseLine(`Deleted \"${pathToDelete}\"`);\n          deletedFiles++;\n        } catch (error) {\n          if (FileSystem.exists(pathToDelete)) {\n            FileSystem.deleteFolder(pathToDelete);\n            logger.terminal.writeVerboseLine(`Deleted folder \"${pathToDelete}\"`);\n            deletedFolders++;\n          }\n        }\n      },\n      { concurrency: Constants.maxParallelism }\n    );\n\n    if (deletedFiles > 0 || deletedFolders > 0) {\n      logger.terminal.writeLine(\n        `Deleted ${deletedFiles} file${deletedFiles !== 1 ? 's' : ''} ` +\n          `and ${deletedFolders} folder${deletedFolders !== 1 ? 's' : ''}`\n      );\n    }\n  }\n\n  private async _resolvePathAsync(globPattern: string, buildFolder: string): Promise<string[]> {\n    if (globEscape(globPattern) !== globPattern) {\n      const expandedGlob: string[] = await LegacyAdapters.convertCallbackToPromise(glob, globPattern, {\n        cwd: buildFolder\n      });\n\n      const result: string[] = [];\n      for (const pathFromGlob of expandedGlob) {\n        result.push(path.resolve(buildFolder, pathFromGlob));\n      }\n\n      return result;\n    } else {\n      return [path.resolve(buildFolder, globPattern)];\n    }\n  }\n}\n"]}