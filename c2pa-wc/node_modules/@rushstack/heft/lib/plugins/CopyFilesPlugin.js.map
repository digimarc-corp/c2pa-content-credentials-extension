{"version":3,"file":"CopyFilesPlugin.js","sourceRoot":"","sources":["../../src/plugins/CopyFilesPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as chokidar from 'chokidar';\nimport * as path from 'path';\nimport glob from 'fast-glob';\nimport { performance } from 'perf_hooks';\nimport { AlreadyExistsBehavior, FileSystem, Async } from '@rushstack/node-core-library';\n\nimport { HeftAsync } from '../utilities/HeftAsync';\nimport { ScopedLogger } from '../pluginFramework/logging/ScopedLogger';\nimport { HeftEventPluginBase } from '../pluginFramework/HeftEventPluginBase';\nimport { HeftSession } from '../pluginFramework/HeftSession';\nimport { HeftConfiguration } from '../configuration/HeftConfiguration';\nimport {\n  IExtendedSharedCopyConfiguration,\n  IHeftEventActions,\n  IHeftConfigurationCopyFilesEventAction,\n  HeftEvent\n} from '../utilities/CoreConfigFiles';\nimport { IBuildStageProperties } from '../stages/BuildStage';\nimport { Constants } from '../utilities/Constants';\n\ninterface ICopyFileDescriptor {\n  sourceFilePath: string;\n  destinationFilePath: string;\n  hardlink: boolean;\n}\n\nexport interface IResolvedDestinationCopyConfiguration extends IExtendedSharedCopyConfiguration {\n  /**\n   * Fully-qualified folder paths to which files should be copied.\n   */\n  resolvedDestinationFolderPaths: string[];\n}\n\nexport interface ICopyFilesOptions {\n  buildFolder: string;\n  copyConfigurations: IResolvedDestinationCopyConfiguration[];\n  logger: ScopedLogger;\n  watchMode: boolean;\n}\n\nexport interface ICopyFilesResult {\n  copiedFileCount: number;\n  linkedFileCount: number;\n}\n\nexport class CopyFilesPlugin extends HeftEventPluginBase<IHeftConfigurationCopyFilesEventAction> {\n  public readonly pluginName: string = 'CopyFilesPlugin';\n  protected eventActionName: keyof IHeftEventActions = 'copyFiles';\n  protected loggerName: string = 'copy-files';\n\n  /**\n   * @override\n   */\n  protected async handleBuildEventActionsAsync(\n    heftEvent: HeftEvent,\n    heftEventActions: IHeftConfigurationCopyFilesEventAction[],\n    logger: ScopedLogger,\n    heftSession: HeftSession,\n    heftConfiguration: HeftConfiguration,\n    properties: IBuildStageProperties\n  ): Promise<void> {\n    await this._runCopyFilesForHeftEventActions(heftEventActions, logger, heftConfiguration);\n  }\n\n  private async _runCopyFilesForHeftEventActions(\n    heftEventActions: IHeftConfigurationCopyFilesEventAction[],\n    logger: ScopedLogger,\n    heftConfiguration: HeftConfiguration\n  ): Promise<void> {\n    const copyConfigurations: IResolvedDestinationCopyConfiguration[] = [];\n    for (const copyFilesEventAction of heftEventActions) {\n      for (const copyOperation of copyFilesEventAction.copyOperations) {\n        copyConfigurations.push({\n          ...copyOperation,\n          resolvedDestinationFolderPaths: copyOperation.destinationFolders.map((destinationFolder) =>\n            path.join(heftConfiguration.buildFolder, destinationFolder)\n          )\n        });\n      }\n    }\n\n    await this.runCopyAsync({\n      buildFolder: heftConfiguration.buildFolder,\n      copyConfigurations,\n      logger,\n      watchMode: false\n    });\n  }\n\n  protected async runCopyAsync(options: ICopyFilesOptions): Promise<void> {\n    const { logger, buildFolder, copyConfigurations } = options;\n\n    const startTime: number = performance.now();\n    const copyDescriptors: ICopyFileDescriptor[] = await this._getCopyFileDescriptorsAsync(\n      buildFolder,\n      copyConfigurations\n    );\n\n    if (copyDescriptors.length === 0) {\n      // No need to run copy and print to console\n      return;\n    }\n\n    const { copiedFileCount, linkedFileCount } = await this._copyFilesAsync(copyDescriptors);\n    const duration: number = performance.now() - startTime;\n    logger.terminal.writeLine(\n      `Copied ${copiedFileCount} file${copiedFileCount === 1 ? '' : 's'} and ` +\n        `linked ${linkedFileCount} file${linkedFileCount === 1 ? '' : 's'} in ${Math.round(duration)}ms`\n    );\n\n    // Then enter watch mode if requested\n    if (options.watchMode) {\n      HeftAsync.runWatcherWithErrorHandling(async () => await this._runWatchAsync(options), logger);\n    }\n  }\n\n  private async _copyFilesAsync(copyDescriptors: ICopyFileDescriptor[]): Promise<ICopyFilesResult> {\n    if (copyDescriptors.length === 0) {\n      return { copiedFileCount: 0, linkedFileCount: 0 };\n    }\n\n    let copiedFileCount: number = 0;\n    let linkedFileCount: number = 0;\n    await Async.forEachAsync(\n      copyDescriptors,\n      async (copyDescriptor: ICopyFileDescriptor) => {\n        if (copyDescriptor.hardlink) {\n          linkedFileCount++;\n          await FileSystem.createHardLinkAsync({\n            linkTargetPath: copyDescriptor.sourceFilePath,\n            newLinkPath: copyDescriptor.destinationFilePath,\n            alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite\n          });\n        } else {\n          copiedFileCount++;\n          await FileSystem.copyFileAsync({\n            sourcePath: copyDescriptor.sourceFilePath,\n            destinationPath: copyDescriptor.destinationFilePath,\n            alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite\n          });\n        }\n      },\n      { concurrency: Constants.maxParallelism }\n    );\n\n    return {\n      copiedFileCount,\n      linkedFileCount\n    };\n  }\n\n  private async _getCopyFileDescriptorsAsync(\n    buildFolder: string,\n    copyConfigurations: IResolvedDestinationCopyConfiguration[]\n  ): Promise<ICopyFileDescriptor[]> {\n    const processedCopyDescriptors: ICopyFileDescriptor[] = [];\n\n    // Create a map to deduplicate and prevent double-writes\n    // resolvedDestinationFilePath -> descriptor\n    const destinationCopyDescriptors: Map<string, ICopyFileDescriptor> = new Map();\n\n    for (const copyConfiguration of copyConfigurations) {\n      // Resolve the source folder path which is where the glob will be run from\n      const resolvedSourceFolderPath: string = path.resolve(buildFolder, copyConfiguration.sourceFolder);\n      const sourceFileRelativePaths: Set<string> = new Set<string>(\n        await glob(this._getIncludedGlobPatterns(copyConfiguration), {\n          cwd: resolvedSourceFolderPath,\n          ignore: copyConfiguration.excludeGlobs,\n          dot: true,\n          onlyFiles: true\n        })\n      );\n\n      // Dedupe and throw if a double-write is detected\n      for (const destinationFolderPath of copyConfiguration.resolvedDestinationFolderPaths) {\n        for (const sourceFileRelativePath of sourceFileRelativePaths) {\n          // Only include the relative path from the sourceFolder if flatten is false\n          const resolvedSourceFilePath: string = path.join(resolvedSourceFolderPath, sourceFileRelativePath);\n          const resolvedDestinationFilePath: string = path.resolve(\n            destinationFolderPath,\n            copyConfiguration.flatten ? '.' : path.dirname(sourceFileRelativePath),\n            path.basename(sourceFileRelativePath)\n          );\n\n          // Throw if a duplicate copy target with a different source or options is specified\n          const existingDestinationCopyDescriptor: ICopyFileDescriptor | undefined =\n            destinationCopyDescriptors.get(resolvedDestinationFilePath);\n          if (existingDestinationCopyDescriptor) {\n            if (\n              existingDestinationCopyDescriptor.sourceFilePath === resolvedSourceFilePath &&\n              existingDestinationCopyDescriptor.hardlink === !!copyConfiguration.hardlink\n            ) {\n              // Found a duplicate, avoid adding again\n              continue;\n            }\n            throw new Error(\n              `Cannot copy different files to the same destination \"${resolvedDestinationFilePath}\"`\n            );\n          }\n\n          // Finally, default hardlink to false, add to the result, and add to the map for deduping\n          const processedCopyDescriptor: ICopyFileDescriptor = {\n            sourceFilePath: resolvedSourceFilePath,\n            destinationFilePath: resolvedDestinationFilePath,\n            hardlink: !!copyConfiguration.hardlink\n          };\n          processedCopyDescriptors.push(processedCopyDescriptor);\n          destinationCopyDescriptors.set(resolvedDestinationFilePath, processedCopyDescriptor);\n        }\n      }\n    }\n\n    // We're done with the map, grab the values and return\n    return processedCopyDescriptors;\n  }\n\n  private _getIncludedGlobPatterns(copyConfiguration: IExtendedSharedCopyConfiguration): string[] {\n    const patternsToGlob: Set<string> = new Set<string>();\n\n    // Glob file extensions with a specific glob to increase perf\n    const escapedFileExtensions: Set<string> = new Set<string>();\n    for (const fileExtension of copyConfiguration.fileExtensions || []) {\n      let escapedFileExtension: string;\n      if (fileExtension.charAt(0) === '.') {\n        escapedFileExtension = fileExtension.substr(1);\n      } else {\n        escapedFileExtension = fileExtension;\n      }\n\n      escapedFileExtension = glob.escapePath(escapedFileExtension);\n      escapedFileExtensions.add(escapedFileExtension);\n    }\n\n    if (escapedFileExtensions.size > 1) {\n      patternsToGlob.add(`**/*.{${Array.from(escapedFileExtensions).join(',')}}`);\n    } else if (escapedFileExtensions.size === 1) {\n      patternsToGlob.add(`**/*.${Array.from(escapedFileExtensions)[0]}`);\n    }\n\n    // Now include the other globs as well\n    for (const include of copyConfiguration.includeGlobs || []) {\n      patternsToGlob.add(include);\n    }\n\n    return Array.from(patternsToGlob);\n  }\n\n  private async _runWatchAsync(options: ICopyFilesOptions): Promise<void> {\n    const { buildFolder, copyConfigurations, logger } = options;\n\n    for (const copyConfiguration of copyConfigurations) {\n      // Obtain the glob patterns to provide to the watcher\n      const globsToWatch: string[] = this._getIncludedGlobPatterns(copyConfiguration);\n      if (globsToWatch.length) {\n        const resolvedSourceFolderPath: string = path.join(buildFolder, copyConfiguration.sourceFolder);\n\n        const watcher: chokidar.FSWatcher = chokidar.watch(globsToWatch, {\n          cwd: resolvedSourceFolderPath,\n          ignoreInitial: true,\n          ignored: copyConfiguration.excludeGlobs\n        });\n\n        const copyAsset: (relativeAssetPath: string) => Promise<void> = async (relativeAssetPath: string) => {\n          const { copiedFileCount, linkedFileCount } = await this._copyFilesAsync(\n            copyConfiguration.resolvedDestinationFolderPaths.map((resolvedDestinationFolderPath) => {\n              return {\n                sourceFilePath: path.join(resolvedSourceFolderPath, relativeAssetPath),\n                destinationFilePath: path.join(\n                  resolvedDestinationFolderPath,\n                  copyConfiguration.flatten ? path.basename(relativeAssetPath) : relativeAssetPath\n                ),\n                hardlink: !!copyConfiguration.hardlink\n              };\n            })\n          );\n          logger.terminal.writeLine(\n            copyConfiguration.hardlink\n              ? `Linked ${linkedFileCount} file${linkedFileCount === 1 ? '' : 's'}`\n              : `Copied ${copiedFileCount} file${copiedFileCount === 1 ? '' : 's'}`\n          );\n        };\n\n        const deleteAsset: (relativeAssetPath: string) => Promise<void> = async (relativeAssetPath) => {\n          const deletePromises: Promise<void>[] = copyConfiguration.resolvedDestinationFolderPaths.map(\n            (resolvedDestinationFolderPath) =>\n              FileSystem.deleteFileAsync(path.resolve(resolvedDestinationFolderPath, relativeAssetPath))\n          );\n          await Promise.all(deletePromises);\n          logger.terminal.writeLine(\n            `Deleted ${deletePromises.length} file${deletePromises.length === 1 ? '' : 's'}`\n          );\n        };\n\n        watcher.on('add', copyAsset);\n        watcher.on('change', copyAsset);\n        watcher.on('unlink', deleteAsset);\n      }\n    }\n\n    return new Promise(() => {\n      /* never resolve */\n    });\n  }\n}\n"]}