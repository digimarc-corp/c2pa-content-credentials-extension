"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitFilesPatch = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
class EmitFilesPatch {
    static install(ts, tsconfig, moduleKindsToEmit, changedFiles) {
        if (EmitFilesPatch._patchedTs === ts) {
            // We already patched this instance of TS
            return;
        }
        if (EmitFilesPatch._patchedTs !== undefined) {
            throw new node_core_library_1.InternalError('EmitFilesPatch.install() cannot be called without first uninstalling the existing patch');
        }
        EmitFilesPatch._patchedTs = ts;
        EmitFilesPatch._baseEmitFiles = ts.emitFiles;
        let foundPrimary = false;
        let defaultModuleKind;
        for (const moduleKindToEmit of moduleKindsToEmit) {
            if (moduleKindToEmit.isPrimary) {
                if (foundPrimary) {
                    throw new Error('Multiple primary module emit kinds encountered.');
                }
                else {
                    foundPrimary = true;
                }
                defaultModuleKind = moduleKindToEmit.moduleKind;
            }
        }
        // Override the underlying file emitter to run itself once for each flavor
        // This is a rather inelegant way to convince the TypeScript compiler not to duplicate parse/link/check
        ts.emitFiles = (resolver, host, targetSourceFile, emitTransformers, emitOnlyDtsFiles, onlyBuildInfo, forceDtsEmit) => {
            if (onlyBuildInfo || emitOnlyDtsFiles) {
                // There should only be one tsBuildInfo and one set of declaration files
                return EmitFilesPatch._baseEmitFiles(resolver, host, targetSourceFile, emitTransformers, emitOnlyDtsFiles, onlyBuildInfo, forceDtsEmit);
            }
            else {
                if (targetSourceFile && changedFiles) {
                    changedFiles.add(targetSourceFile);
                }
                let defaultModuleKindResult;
                const diagnostics = [];
                let emitSkipped = false;
                for (const moduleKindToEmit of moduleKindsToEmit) {
                    const compilerOptions = moduleKindToEmit.isPrimary
                        ? Object.assign({}, tsconfig.options) : Object.assign(Object.assign({}, tsconfig.options), { module: moduleKindToEmit.moduleKind, outDir: moduleKindToEmit.outFolderPath, 
                        // Don't emit declarations for secondary module kinds
                        declaration: false, declarationMap: false });
                    if (!compilerOptions.outDir) {
                        throw new node_core_library_1.InternalError('Expected compilerOptions.outDir to be assigned');
                    }
                    const flavorResult = EmitFilesPatch._baseEmitFiles(resolver, Object.assign(Object.assign({}, host), { writeFile: EmitFilesPatch.wrapWriteFile(host.writeFile, moduleKindToEmit.jsExtensionOverride), getCompilerOptions: () => compilerOptions }), targetSourceFile, ts.getTransformers(compilerOptions, undefined, emitOnlyDtsFiles), emitOnlyDtsFiles, onlyBuildInfo, forceDtsEmit);
                    emitSkipped = emitSkipped || flavorResult.emitSkipped;
                    for (const diagnostic of flavorResult.diagnostics) {
                        diagnostics.push(diagnostic);
                    }
                    if (moduleKindToEmit.moduleKind === defaultModuleKind) {
                        defaultModuleKindResult = flavorResult;
                    }
                    // Should results be aggregated, in case for whatever reason the diagnostics are not the same?
                }
                const mergedDiagnostics = ts.sortAndDeduplicateDiagnostics(diagnostics);
                return Object.assign(Object.assign({}, defaultModuleKindResult), { diagnostics: mergedDiagnostics, emitSkipped });
            }
        };
    }
    static get isInstalled() {
        return this._patchedTs !== undefined;
    }
    /**
     * Wraps the writeFile callback on the IEmitHost to override the .js extension, if applicable
     */
    static wrapWriteFile(baseWriteFile, jsExtensionOverride) {
        if (!jsExtensionOverride) {
            return baseWriteFile;
        }
        const replacementExtension = `${jsExtensionOverride}$1`;
        return (fileName, data, writeBOM, onError, sourceFiles) => {
            return baseWriteFile(fileName.replace(/\.js(\.map)?$/g, replacementExtension), data, writeBOM, onError, sourceFiles);
        };
    }
    static uninstall(ts) {
        if (EmitFilesPatch._patchedTs === undefined) {
            throw new node_core_library_1.InternalError('EmitFilesPatch.uninstall() cannot be called if no patch was installed');
        }
        if (ts !== EmitFilesPatch._patchedTs) {
            throw new node_core_library_1.InternalError('EmitFilesPatch.uninstall() called for the wrong object');
        }
        ts.emitFiles = EmitFilesPatch._baseEmitFiles;
        EmitFilesPatch._patchedTs = undefined;
        EmitFilesPatch._baseEmitFiles = undefined;
    }
}
exports.EmitFilesPatch = EmitFilesPatch;
EmitFilesPatch._patchedTs = undefined;
EmitFilesPatch._baseEmitFiles = undefined; // eslint-disable-line
//# sourceMappingURL=EmitFilesPatch.js.map