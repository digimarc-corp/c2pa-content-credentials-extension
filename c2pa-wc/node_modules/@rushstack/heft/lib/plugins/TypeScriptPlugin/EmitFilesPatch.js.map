{"version":3,"file":"EmitFilesPatch.js","sourceRoot":"","sources":["../../../src/plugins/TypeScriptPlugin/EmitFilesPatch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { InternalError } from '@rushstack/node-core-library';\nimport type * as TTypescript from 'typescript';\nimport {\n  ExtendedTypeScript,\n  IEmitResolver,\n  IEmitHost,\n  IEmitTransformers,\n  IExtendedSourceFile\n} from './internalTypings/TypeScriptInternals';\n\nexport interface ICachedEmitModuleKind {\n  moduleKind: TTypescript.ModuleKind;\n\n  outFolderPath: string;\n\n  /**\n   * File extension to use instead of '.js' for emitted ECMAScript files.\n   * For example, '.cjs' to indicate commonjs content, or '.mjs' to indicate ECMAScript modules.\n   */\n  jsExtensionOverride: string | undefined;\n\n  /**\n   * Set to true if this is the emit kind that is specified in the tsconfig.json.\n   * Declarations are only emitted for the primary module kind.\n   */\n  isPrimary: boolean;\n}\n\nexport class EmitFilesPatch {\n  private static _patchedTs: ExtendedTypeScript | undefined = undefined;\n\n  private static _baseEmitFiles: any | undefined = undefined; // eslint-disable-line\n\n  public static install(\n    ts: ExtendedTypeScript,\n    tsconfig: TTypescript.ParsedCommandLine,\n    moduleKindsToEmit: ICachedEmitModuleKind[],\n    changedFiles?: Set<IExtendedSourceFile>\n  ): void {\n    if (EmitFilesPatch._patchedTs === ts) {\n      // We already patched this instance of TS\n      return;\n    }\n\n    if (EmitFilesPatch._patchedTs !== undefined) {\n      throw new InternalError(\n        'EmitFilesPatch.install() cannot be called without first uninstalling the existing patch'\n      );\n    }\n\n    EmitFilesPatch._patchedTs = ts;\n    EmitFilesPatch._baseEmitFiles = ts.emitFiles;\n\n    let foundPrimary: boolean = false;\n    let defaultModuleKind: TTypescript.ModuleKind;\n\n    for (const moduleKindToEmit of moduleKindsToEmit) {\n      if (moduleKindToEmit.isPrimary) {\n        if (foundPrimary) {\n          throw new Error('Multiple primary module emit kinds encountered.');\n        } else {\n          foundPrimary = true;\n        }\n\n        defaultModuleKind = moduleKindToEmit.moduleKind;\n      }\n    }\n\n    // Override the underlying file emitter to run itself once for each flavor\n    // This is a rather inelegant way to convince the TypeScript compiler not to duplicate parse/link/check\n    ts.emitFiles = (\n      resolver: IEmitResolver,\n      host: IEmitHost,\n      targetSourceFile: IExtendedSourceFile | undefined,\n      emitTransformers: IEmitTransformers,\n      emitOnlyDtsFiles?: boolean,\n      onlyBuildInfo?: boolean,\n      forceDtsEmit?: boolean\n    ): TTypescript.EmitResult => {\n      if (onlyBuildInfo || emitOnlyDtsFiles) {\n        // There should only be one tsBuildInfo and one set of declaration files\n        return EmitFilesPatch._baseEmitFiles(\n          resolver,\n          host,\n          targetSourceFile,\n          emitTransformers,\n          emitOnlyDtsFiles,\n          onlyBuildInfo,\n          forceDtsEmit\n        );\n      } else {\n        if (targetSourceFile && changedFiles) {\n          changedFiles.add(targetSourceFile);\n        }\n\n        let defaultModuleKindResult: TTypescript.EmitResult;\n        const diagnostics: TTypescript.Diagnostic[] = [];\n        let emitSkipped: boolean = false;\n        for (const moduleKindToEmit of moduleKindsToEmit) {\n          const compilerOptions: TTypescript.CompilerOptions = moduleKindToEmit.isPrimary\n            ? {\n                ...tsconfig.options\n              }\n            : {\n                ...tsconfig.options,\n                module: moduleKindToEmit.moduleKind,\n                outDir: moduleKindToEmit.outFolderPath,\n\n                // Don't emit declarations for secondary module kinds\n                declaration: false,\n                declarationMap: false\n              };\n\n          if (!compilerOptions.outDir) {\n            throw new InternalError('Expected compilerOptions.outDir to be assigned');\n          }\n\n          const flavorResult: TTypescript.EmitResult = EmitFilesPatch._baseEmitFiles(\n            resolver,\n            {\n              ...host,\n              writeFile: EmitFilesPatch.wrapWriteFile(host.writeFile, moduleKindToEmit.jsExtensionOverride),\n              getCompilerOptions: () => compilerOptions\n            },\n            targetSourceFile,\n            ts.getTransformers(compilerOptions, undefined, emitOnlyDtsFiles),\n            emitOnlyDtsFiles,\n            onlyBuildInfo,\n            forceDtsEmit\n          );\n\n          emitSkipped = emitSkipped || flavorResult.emitSkipped;\n          for (const diagnostic of flavorResult.diagnostics) {\n            diagnostics.push(diagnostic);\n          }\n\n          if (moduleKindToEmit.moduleKind === defaultModuleKind) {\n            defaultModuleKindResult = flavorResult;\n          }\n          // Should results be aggregated, in case for whatever reason the diagnostics are not the same?\n        }\n\n        const mergedDiagnostics: readonly TTypescript.Diagnostic[] =\n          ts.sortAndDeduplicateDiagnostics(diagnostics);\n\n        return {\n          ...defaultModuleKindResult!,\n          diagnostics: mergedDiagnostics,\n          emitSkipped\n        };\n      }\n    };\n  }\n\n  public static get isInstalled(): boolean {\n    return this._patchedTs !== undefined;\n  }\n\n  /**\n   * Wraps the writeFile callback on the IEmitHost to override the .js extension, if applicable\n   */\n  public static wrapWriteFile(\n    baseWriteFile: TTypescript.WriteFileCallback,\n    jsExtensionOverride: string | undefined\n  ): TTypescript.WriteFileCallback {\n    if (!jsExtensionOverride) {\n      return baseWriteFile;\n    }\n\n    const replacementExtension: string = `${jsExtensionOverride}$1`;\n    return (\n      fileName: string,\n      data: string,\n      writeBOM: boolean,\n      onError?: ((message: string) => void) | undefined,\n      sourceFiles?: readonly TTypescript.SourceFile[] | undefined\n    ) => {\n      return baseWriteFile(\n        fileName.replace(/\\.js(\\.map)?$/g, replacementExtension),\n        data,\n        writeBOM,\n        onError,\n        sourceFiles\n      );\n    };\n  }\n\n  public static uninstall(ts: ExtendedTypeScript): void {\n    if (EmitFilesPatch._patchedTs === undefined) {\n      throw new InternalError('EmitFilesPatch.uninstall() cannot be called if no patch was installed');\n    }\n    if (ts !== EmitFilesPatch._patchedTs) {\n      throw new InternalError('EmitFilesPatch.uninstall() called for the wrong object');\n    }\n\n    ts.emitFiles = EmitFilesPatch._baseEmitFiles;\n\n    EmitFilesPatch._patchedTs = undefined;\n    EmitFilesPatch._baseEmitFiles = undefined;\n  }\n}\n"]}