"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptBuilder = void 0;
const crypto = __importStar(require("crypto"));
const path = __importStar(require("path"));
const semver = __importStar(require("semver"));
const node_core_library_1 = require("@rushstack/node-core-library");
const SubprocessRunnerBase_1 = require("../../utilities/subprocess/SubprocessRunnerBase");
const Tslint_1 = require("./Tslint");
const Eslint_1 = require("./Eslint");
const EmitFilesPatch_1 = require("./EmitFilesPatch");
const EmitCompletedCallbackManager_1 = require("./EmitCompletedCallbackManager");
const TypeScriptCachedFileSystem_1 = require("../../utilities/fileSystem/TypeScriptCachedFileSystem");
const EMPTY_JSON = {};
const OLDEST_SUPPORTED_TS_MAJOR_VERSION = 2;
const OLDEST_SUPPORTED_TS_MINOR_VERSION = 9;
const NEWEST_SUPPORTED_TS_MAJOR_VERSION = 4;
const NEWEST_SUPPORTED_TS_MINOR_VERSION = 7;
class TypeScriptBuilder extends SubprocessRunnerBase_1.SubprocessRunnerBase {
    constructor(parentGlobalTerminalProvider, configuration, heftSession, emitCallback) {
        super(parentGlobalTerminalProvider, configuration, heftSession);
        this._tsReadJsonCache = new Map();
        this._cachedFileSystem = new TypeScriptCachedFileSystem_1.TypeScriptCachedFileSystem();
        this._emitCompletedCallbackManager = new EmitCompletedCallbackManager_1.EmitCompletedCallbackManager(emitCallback);
        this.registerSubprocessCommunicationManager(this._emitCompletedCallbackManager);
    }
    get filename() {
        return __filename;
    }
    get _tsCacheFilePath() {
        if (!this.__tsCacheFilePath) {
            // TypeScript internally handles if the tsconfig options have changed from when the tsbuildinfo file was created.
            // We only need to hash our additional Heft configuration.
            const configHash = crypto.createHash('sha1');
            configHash.update(JSON.stringify(this._configuration.additionalModuleKindsToEmit || {}));
            const serializedConfigHash = configHash
                .digest('base64')
                .slice(0, 8)
                .replace(/\+/g, '-')
                .replace(/\//g, '_');
            // This conversion is theoretically redundant, but it is here to make absolutely sure that the path is formatted
            // using only '/' as the directory separator so that incremental builds don't break on Windows.
            // TypeScript will normalize to '/' when serializing, but not on the direct input, and uses exact string equality.
            const normalizedCacheFolder = node_core_library_1.Path.convertToSlashes(this._configuration.buildMetadataFolder);
            this.__tsCacheFilePath = `${normalizedCacheFolder}/ts_${serializedConfigHash}.json`;
        }
        return this.__tsCacheFilePath;
    }
    async invokeAsync() {
        this._typescriptLogger = await this.requestScopedLoggerAsync('typescript');
        this._typescriptTerminal = this._typescriptLogger.terminal;
        // Determine the compiler version
        const compilerPackageJsonFilename = path.join(this._configuration.typeScriptToolPath, 'package.json');
        const packageJson = node_core_library_1.JsonFile.load(compilerPackageJsonFilename);
        this._typescriptVersion = packageJson.version;
        const parsedVersion = semver.parse(this._typescriptVersion);
        if (!parsedVersion) {
            throw new Error(`Unable to parse version "${this._typescriptVersion}" for TypeScript compiler package in: ` +
                compilerPackageJsonFilename);
        }
        this._typescriptParsedVersion = parsedVersion;
        // Detect what features this compiler supports.  Note that manually comparing major/minor numbers
        // loosens the matching to accept prereleases such as "3.6.0-dev.20190530"
        this._capabilities = {
            incrementalProgram: false,
            solutionBuilder: this._typescriptParsedVersion.major >= 3
        };
        if (this._typescriptParsedVersion.major > 3 ||
            (this._typescriptParsedVersion.major === 3 && this._typescriptParsedVersion.minor >= 6)) {
            this._capabilities.incrementalProgram = true;
        }
        this._useSolutionBuilder = !!this._configuration.buildProjectReferences;
        if (this._useSolutionBuilder && !this._capabilities.solutionBuilder) {
            throw new Error(`Building project references requires TypeScript@>=3.0, but the current version is ${this._typescriptVersion}`);
        }
        this._tslintConfigFilePath = path.resolve(this._configuration.buildFolder, 'tslint.json');
        this._eslintEnabled = this._tslintEnabled =
            this._configuration.lintingEnabled && !this._configuration.watchMode; // Don't run lint in watch mode
        if (this._tslintEnabled) {
            this._tslintEnabled = this._cachedFileSystem.exists(this._tslintConfigFilePath);
        }
        this._eslintConfigFilePath = this._resolveEslintConfigFilePath(this._eslintEnabled);
        if (this._eslintEnabled) {
            this._eslintEnabled = this._cachedFileSystem.exists(this._eslintConfigFilePath);
        }
        // Report a warning if the TypeScript version is too old/new.  The current oldest supported version is
        // TypeScript 2.9. Prior to that the "ts.getConfigFileParsingDiagnostics()" API is missing; more fixups
        // would be required to deal with that.  We won't do that work unless someone requests it.
        if (this._typescriptParsedVersion.major < OLDEST_SUPPORTED_TS_MAJOR_VERSION ||
            (this._typescriptParsedVersion.major === OLDEST_SUPPORTED_TS_MAJOR_VERSION &&
                this._typescriptParsedVersion.minor < OLDEST_SUPPORTED_TS_MINOR_VERSION)) {
            // We don't use writeWarningLine() here because, if the person wants to take their chances with
            // a seemingly unsupported compiler, their build should be allowed to succeed.
            this._typescriptTerminal.writeLine(`The TypeScript compiler version ${this._typescriptVersion} is very old` +
                ` and has not been tested with Heft; it may not work correctly.`);
        }
        else if (this._typescriptParsedVersion.major > NEWEST_SUPPORTED_TS_MAJOR_VERSION ||
            (this._typescriptParsedVersion.major === NEWEST_SUPPORTED_TS_MAJOR_VERSION &&
                this._typescriptParsedVersion.minor > NEWEST_SUPPORTED_TS_MINOR_VERSION)) {
            this._typescriptTerminal.writeLine(`The TypeScript compiler version ${this._typescriptVersion} is newer` +
                ' than the latest version that was tested with Heft ' +
                `(${NEWEST_SUPPORTED_TS_MAJOR_VERSION}.${NEWEST_SUPPORTED_TS_MINOR_VERSION}); it may not work correctly.`);
        }
        const ts = require(this._configuration.typeScriptToolPath);
        ts.performance.enable();
        const measureTsPerformance = (measurementName, fn) => {
            const beforeName = `before${measurementName}`;
            ts.performance.mark(beforeName);
            const result = fn();
            const afterName = `after${measurementName}`;
            ts.performance.mark(afterName);
            ts.performance.measure(measurementName, beforeName, afterName);
            return Object.assign(Object.assign({}, result), { duration: ts.performance.getDuration(measurementName), count: ts.performance.getCount(beforeName) });
        };
        const measureTsPerformanceAsync = async (measurementName, fn) => {
            const beforeName = `before${measurementName}`;
            ts.performance.mark(beforeName);
            const resultPromise = fn();
            const result = await resultPromise;
            const afterName = `after${measurementName}`;
            ts.performance.mark(afterName);
            ts.performance.measure(measurementName, beforeName, afterName);
            return Object.assign(Object.assign({}, result), { duration: ts.performance.getDuration(measurementName) });
        };
        this._typescriptTerminal.writeLine(`Using TypeScript version ${ts.version}`);
        if (this._configuration.watchMode) {
            await this._runWatch(ts, measureTsPerformance);
        }
        else if (this._useSolutionBuilder) {
            await this._runSolutionBuildAsync(ts, measureTsPerformance, measureTsPerformanceAsync);
        }
        else {
            await this._runBuildAsync(ts, measureTsPerformance, measureTsPerformanceAsync);
        }
    }
    _resolveEslintConfigFilePath(eslintEnabled) {
        const defaultPath = path.resolve(this._configuration.buildFolder, '.eslintrc.js');
        if (!eslintEnabled) {
            return defaultPath; // No need to check the filesystem
        }
        // When project is configured with "type": "module" in package.json, the config file must have a .cjs extension
        // so use it if it exists
        const alternativePathPath = path.resolve(this._configuration.buildFolder, '.eslintrc.cjs');
        if (this._cachedFileSystem.exists(alternativePathPath)) {
            return alternativePathPath;
        }
        return defaultPath;
    }
    async _runWatch(ts, measureTsPerformance) {
        //#region CONFIGURE
        const { duration: configureDurationMs, tsconfig } = measureTsPerformance('Configure', () => {
            const _tsconfig = this._loadTsconfig(ts);
            this._validateTsconfig(ts, _tsconfig);
            EmitFilesPatch_1.EmitFilesPatch.install(ts, _tsconfig, this._moduleKindsToEmit);
            return {
                tsconfig: _tsconfig
            };
        });
        this._typescriptTerminal.writeVerboseLine(`Configure: ${configureDurationMs}ms`);
        //#endregion
        if (this._useSolutionBuilder) {
            const solutionHost = this._buildWatchSolutionBuilderHost(ts);
            const watchBuilder = ts.createSolutionBuilderWithWatch(solutionHost, [this._configuration.tsconfigPath], {});
            watchBuilder.build();
        }
        else {
            const compilerHost = this._buildWatchCompilerHost(ts, tsconfig);
            ts.createWatchProgram(compilerHost);
        }
        return new Promise(() => {
            /* never terminate */
        });
    }
    async _runBuildAsync(ts, measureTsPerformance, measureTsPerformanceAsync) {
        //#region CONFIGURE
        const { duration: configureDurationMs, tsconfig, compilerHost } = measureTsPerformance('Configure', () => {
            this._overrideTypeScriptReadJson(ts);
            const _tsconfig = this._loadTsconfig(ts);
            this._validateTsconfig(ts, _tsconfig);
            const _compilerHost = this._buildIncrementalCompilerHost(ts, _tsconfig);
            return {
                tsconfig: _tsconfig,
                compilerHost: _compilerHost
            };
        });
        this._typescriptTerminal.writeVerboseLine(`Configure: ${configureDurationMs}ms`);
        //#endregion
        //#region PROGRAM
        // There will be only one program here; emit will get a bit abused if we produce multiple outputs
        let builderProgram = undefined;
        let tsProgram;
        if (tsconfig.options.incremental) {
            builderProgram = ts.createIncrementalProgram({
                rootNames: tsconfig.fileNames,
                options: tsconfig.options,
                projectReferences: tsconfig.projectReferences,
                host: compilerHost,
                configFileParsingDiagnostics: ts.getConfigFileParsingDiagnostics(tsconfig)
            });
            tsProgram = builderProgram.getProgram();
        }
        else {
            tsProgram = ts.createProgram({
                rootNames: tsconfig.fileNames,
                options: tsconfig.options,
                projectReferences: tsconfig.projectReferences,
                host: compilerHost,
                configFileParsingDiagnostics: ts.getConfigFileParsingDiagnostics(tsconfig)
            });
        }
        // Prefer the builder program, since it is what gives us incremental builds
        const genericProgram = builderProgram || tsProgram;
        this._logReadPerformance(ts);
        //#endregion
        //#region ANALYSIS
        const { duration: diagnosticsDurationMs, diagnostics: preDiagnostics } = measureTsPerformance('Analyze', () => {
            const rawDiagnostics = [
                ...genericProgram.getConfigFileParsingDiagnostics(),
                ...genericProgram.getOptionsDiagnostics(),
                ...genericProgram.getSyntacticDiagnostics(),
                ...genericProgram.getGlobalDiagnostics(),
                ...genericProgram.getSemanticDiagnostics()
            ];
            return { diagnostics: rawDiagnostics };
        });
        this._typescriptTerminal.writeVerboseLine(`Analyze: ${diagnosticsDurationMs}ms`);
        //#endregion
        //#region EMIT
        const emitResult = this._emit(ts, tsconfig, genericProgram);
        //#endregion
        this._logEmitPerformance(ts);
        //#region FINAL_ANALYSIS
        // Need to ensure that we include emit diagnostics, since they might not be part of the other sets
        const rawDiagnostics = [...preDiagnostics, ...emitResult.diagnostics];
        //#endregion
        //#region WRITE
        // Using async file system I/O for theoretically better peak performance
        // Also allows to run concurrently with linting
        const writePromise = measureTsPerformanceAsync('Write', () => node_core_library_1.Async.forEachAsync(emitResult.filesToWrite, async ({ filePath, data }) => this._cachedFileSystem.writeFile(filePath, data, { ensureFolderExists: true }), { concurrency: this._configuration.maxWriteParallelism }));
        //#endregion
        const [eslint, tslint] = await Promise.all([
            this._initESlintAsync(ts, measureTsPerformance, measureTsPerformanceAsync),
            this._initTSlintAsync(ts, measureTsPerformance, measureTsPerformanceAsync)
        ]);
        const lintPromises = [];
        const extendedProgram = tsProgram;
        //#region ESLINT
        if (eslint) {
            lintPromises.push(this._runESlintAsync(eslint, extendedProgram, emitResult.changedSourceFiles));
        }
        //#endregion
        //#region TSLINT
        if (tslint) {
            lintPromises.push(this._runTSlintAsync(tslint, extendedProgram, emitResult.changedSourceFiles));
        }
        //#endregion
        const { duration: writeDuration } = await writePromise;
        this._typescriptTerminal.writeVerboseLine(`I/O Write: ${writeDuration}ms (${emitResult.filesToWrite.length} files)`);
        // In non-watch mode, notify EmitCompletedCallbackManager once after we complete the compile step
        this._emitCompletedCallbackManager.callback();
        const linters = await Promise.all(lintPromises);
        this._logDiagnostics(ts, rawDiagnostics, linters);
    }
    async _runSolutionBuildAsync(ts, measureTsPerformance, measureTsPerformanceAsync) {
        this._typescriptTerminal.writeVerboseLine(`Using solution mode`);
        const lintPromises = [];
        //#region CONFIGURE
        const { duration: configureDurationMs, rawDiagnostics, solutionBuilderHost } = await measureTsPerformanceAsync('Configure', async () => {
            this._overrideTypeScriptReadJson(ts);
            const _tsconfig = this._loadTsconfig(ts);
            this._validateTsconfig(ts, _tsconfig);
            const _rawDiagnostics = [];
            const reportDiagnostic = (diagnostic) => {
                _rawDiagnostics.push(diagnostic);
            };
            const [eslint, tslint] = await Promise.all([
                this._initESlintAsync(ts, measureTsPerformance, measureTsPerformanceAsync),
                this._initTSlintAsync(ts, measureTsPerformance, measureTsPerformanceAsync)
            ]);
            // TypeScript doesn't have a
            EmitFilesPatch_1.EmitFilesPatch.install(ts, _tsconfig, this._moduleKindsToEmit);
            const _solutionBuilderHost = this._buildSolutionBuilderHost(ts, reportDiagnostic);
            _solutionBuilderHost.afterProgramEmitAndDiagnostics = (program) => {
                const tsProgram = program.getProgram();
                if (tsProgram) {
                    const extendedProgram = tsProgram;
                    if (eslint) {
                        lintPromises.push(this._runESlintAsync(eslint, extendedProgram));
                    }
                    if (tslint) {
                        lintPromises.push(this._runTSlintAsync(tslint, extendedProgram));
                    }
                }
            };
            return {
                rawDiagnostics: _rawDiagnostics,
                solutionBuilderHost: _solutionBuilderHost
            };
        });
        this._typescriptTerminal.writeVerboseLine(`Configure: ${configureDurationMs}ms`);
        //#endregion
        const solutionBuilder = ts.createSolutionBuilder(solutionBuilderHost, [this._configuration.tsconfigPath], {});
        //#region EMIT
        // Ignoring the exit status because we only care about presence of diagnostics
        solutionBuilder.build();
        //#endregion
        this._logReadPerformance(ts);
        this._logEmitPerformance(ts);
        // Use the native metric since we aren't overwriting the writer
        this._typescriptTerminal.writeVerboseLine(`I/O Write: ${ts.performance.getDuration('I/O Write')}ms (${ts.performance.getCount('beforeIOWrite')} files)`);
        // In non-watch mode, notify EmitCompletedCallbackManager once after we complete the compile step
        this._emitCompletedCallbackManager.callback();
        const linters = await Promise.all(lintPromises);
        this._logDiagnostics(ts, rawDiagnostics, linters);
        EmitFilesPatch_1.EmitFilesPatch.uninstall(ts);
    }
    _logDiagnostics(ts, rawDiagnostics, linters) {
        const diagnostics = ts.sortAndDeduplicateDiagnostics(rawDiagnostics);
        let typeScriptErrorCount = 0;
        if (diagnostics.length > 0) {
            this._typescriptTerminal.writeLine(`Encountered ${diagnostics.length} TypeScript issue${diagnostics.length > 1 ? 's' : ''}:`);
            for (const diagnostic of diagnostics) {
                const diagnosticCategory = this._getAdjustedDiagnosticCategory(diagnostic, ts);
                if (diagnosticCategory === ts.DiagnosticCategory.Error) {
                    typeScriptErrorCount++;
                }
                this._printDiagnosticMessage(ts, diagnostic, diagnosticCategory);
            }
        }
        for (const linter of linters) {
            linter.reportFailures();
        }
        if (typeScriptErrorCount > 0) {
            throw new Error(`Encountered TypeScript error${typeScriptErrorCount > 1 ? 's' : ''}`);
        }
    }
    _logEmitPerformance(ts) {
        this._typescriptTerminal.writeVerboseLine(`Bind: ${ts.performance.getDuration('Bind')}ms`);
        this._typescriptTerminal.writeVerboseLine(`Check: ${ts.performance.getDuration('Check')}ms`);
        this._typescriptTerminal.writeVerboseLine(`Transform: ${ts.performance.getDuration('transformTime')}ms ` +
            `(${ts.performance.getCount('beforeTransform')} files)`);
        this._typescriptTerminal.writeVerboseLine(`Print: ${ts.performance.getDuration('printTime')}ms ` +
            `(${ts.performance.getCount('beforePrint')} files) (Includes Transform)`);
        this._typescriptTerminal.writeVerboseLine(`Emit: ${ts.performance.getDuration('Emit')}ms (Includes Print)`);
    }
    _logReadPerformance(ts) {
        this._typescriptTerminal.writeVerboseLine(`I/O Read: ${ts.performance.getDuration('I/O Read')}ms (${ts.performance.getCount('beforeIORead')} files)`);
        this._typescriptTerminal.writeVerboseLine(`Parse: ${ts.performance.getDuration('Parse')}ms (${ts.performance.getCount('beforeParse')} files)`);
        this._typescriptTerminal.writeVerboseLine(`Program (includes Read + Parse): ${ts.performance.getDuration('Program')}ms`);
    }
    async _initTSlintAsync(ts, measureTsPerformance, measureTsPerformanceAsync) {
        if (this._tslintEnabled) {
            if (!this._configuration.tslintToolPath) {
                throw new Error('Unable to resolve "tslint" package');
            }
            const logger = await this.requestScopedLoggerAsync('tslint');
            return {
                logger,
                ts,
                measureTsPerformance,
                measureTsPerformanceAsync
            };
        }
    }
    async _initESlintAsync(ts, measureTsPerformance, measureTsPerformanceAsync) {
        if (this._eslintEnabled) {
            if (!this._configuration.eslintToolPath) {
                throw new Error('Unable to resolve "eslint" package');
            }
            const logger = await this.requestScopedLoggerAsync('eslint');
            return {
                logger,
                ts,
                measureTsPerformance,
                measureTsPerformanceAsync
            };
        }
    }
    async _runESlintAsync(linter, tsProgram, changedFiles) {
        const eslint = new Eslint_1.Eslint({
            ts: linter.ts,
            scopedLogger: linter.logger,
            buildFolderPath: this._configuration.buildFolder,
            buildMetadataFolderPath: this._configuration.buildMetadataFolder,
            linterConfigFilePath: this._eslintConfigFilePath,
            measurePerformance: linter.measureTsPerformance,
            measurePerformanceAsync: linter.measureTsPerformanceAsync,
            eslintPackagePath: this._configuration.eslintToolPath
        });
        eslint.printVersionHeader();
        const typeScriptFilenames = new Set(tsProgram.getRootFileNames());
        await eslint.performLintingAsync({
            tsProgram,
            typeScriptFilenames,
            changedFiles: changedFiles || new Set(tsProgram.getSourceFiles())
        });
        return eslint;
    }
    async _runTSlintAsync(linter, tsProgram, changedFiles) {
        const tslint = new Tslint_1.Tslint({
            ts: linter.ts,
            scopedLogger: linter.logger,
            buildFolderPath: this._configuration.buildFolder,
            buildMetadataFolderPath: this._configuration.buildMetadataFolder,
            linterConfigFilePath: this._tslintConfigFilePath,
            measurePerformance: linter.measureTsPerformance,
            measurePerformanceAsync: linter.measureTsPerformanceAsync,
            cachedFileSystem: this._cachedFileSystem,
            tslintPackagePath: this._configuration.tslintToolPath
        });
        tslint.printVersionHeader();
        const typeScriptFilenames = new Set(tsProgram.getRootFileNames());
        await tslint.performLintingAsync({
            tsProgram,
            typeScriptFilenames,
            changedFiles: changedFiles || new Set(tsProgram.getSourceFiles())
        });
        return tslint;
    }
    _printDiagnosticMessage(ts, diagnostic, diagnosticCategory = this._getAdjustedDiagnosticCategory(diagnostic, ts)) {
        // Code taken from reference example
        let diagnosticMessage;
        let errorObject;
        if (diagnostic.file) {
            const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
            const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
            const formattedMessage = `(TS${diagnostic.code}) ${message}`;
            errorObject = new node_core_library_1.FileError(formattedMessage, {
                absolutePath: diagnostic.file.fileName,
                projectFolder: this._configuration.buildFolder,
                line: line + 1,
                column: character + 1
            });
            diagnosticMessage = errorObject.toString();
        }
        else {
            diagnosticMessage = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
            errorObject = new Error(diagnosticMessage);
        }
        switch (diagnosticCategory) {
            case ts.DiagnosticCategory.Error: {
                this._typescriptLogger.emitError(errorObject);
                break;
            }
            case ts.DiagnosticCategory.Warning: {
                this._typescriptLogger.emitWarning(errorObject);
                break;
            }
            default: {
                this._typescriptTerminal.writeLine(...diagnosticMessage);
                break;
            }
        }
    }
    _getAdjustedDiagnosticCategory(diagnostic, ts) {
        // Workaround for https://github.com/microsoft/TypeScript/issues/40058
        // The compiler reports a hard error for issues such as this:
        //
        //    error TS6133: 'x' is declared but its value is never read.
        //
        // These should properly be treated as warnings, because they are purely cosmetic issues.
        // TODO: Maybe heft should provide a config file for managing DiagnosticCategory mappings.
        if (diagnostic.reportsUnnecessary && diagnostic.category === ts.DiagnosticCategory.Error) {
            return ts.DiagnosticCategory.Warning;
        }
        // These pedantic checks also should not be treated as hard errors
        switch (diagnostic.code) {
            case ts.Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor
                .code:
            case ts.Diagnostics
                .Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1.code:
                return ts.DiagnosticCategory.Warning;
        }
        return diagnostic.category;
    }
    _emit(ts, tsconfig, genericProgram) {
        const filesToWrite = [];
        const changedFiles = new Set();
        EmitFilesPatch_1.EmitFilesPatch.install(ts, tsconfig, this._moduleKindsToEmit, changedFiles);
        const writeFileCallback = (filePath, data) => {
            filesToWrite.push({ filePath, data });
        };
        const result = genericProgram.emit(undefined, // Target source file
        writeFileCallback);
        EmitFilesPatch_1.EmitFilesPatch.uninstall(ts);
        return Object.assign(Object.assign({}, result), { changedSourceFiles: changedFiles, filesToWrite });
    }
    _validateTsconfig(ts, tsconfig) {
        if ((tsconfig.options.module && !tsconfig.options.outDir) ||
            (!tsconfig.options.module && tsconfig.options.outDir)) {
            throw new Error('If either the module or the outDir option is provided in the tsconfig compilerOptions, both must be provided');
        }
        this._moduleKindsToEmit = [];
        const specifiedKinds = new Map();
        const specifiedOutDirs = new Map();
        if (!tsconfig.options.module) {
            throw new Error('If the module tsconfig compilerOption is not provided, the builder must be provided with the ' +
                'additionalModuleKindsToEmit configuration option.');
        }
        if (this._configuration.emitCjsExtensionForCommonJS) {
            this._addModuleKindToEmit(ts.ModuleKind.CommonJS, tsconfig.options.outDir, 
            /* isPrimary */ tsconfig.options.module === ts.ModuleKind.CommonJS, '.cjs');
            const cjsReason = {
                outDir: tsconfig.options.outDir,
                kind: 'CommonJS',
                extension: '.cjs',
                reason: 'emitCjsExtensionForCommonJS'
            };
            specifiedKinds.set(ts.ModuleKind.CommonJS, cjsReason);
            specifiedOutDirs.set(`${tsconfig.options.outDir}:.cjs`, cjsReason);
        }
        if (this._configuration.emitMjsExtensionForESModule) {
            this._addModuleKindToEmit(ts.ModuleKind.ESNext, tsconfig.options.outDir, 
            /* isPrimary */ tsconfig.options.module === ts.ModuleKind.ESNext, '.mjs');
            const mjsReason = {
                outDir: tsconfig.options.outDir,
                kind: 'ESNext',
                extension: '.mjs',
                reason: 'emitMjsExtensionForESModule'
            };
            specifiedKinds.set(ts.ModuleKind.ESNext, mjsReason);
            specifiedOutDirs.set(`${tsconfig.options.outDir}:.mjs`, mjsReason);
        }
        if (!specifiedKinds.has(tsconfig.options.module)) {
            this._addModuleKindToEmit(tsconfig.options.module, tsconfig.options.outDir, 
            /* isPrimary */ true, 
            /* jsExtensionOverride */ undefined);
            const tsConfigReason = {
                outDir: tsconfig.options.outDir,
                kind: ts.ModuleKind[tsconfig.options.module],
                extension: '.js',
                reason: 'tsconfig.json'
            };
            specifiedKinds.set(tsconfig.options.module, tsConfigReason);
            specifiedOutDirs.set(`${tsconfig.options.outDir}:.js`, tsConfigReason);
        }
        if (this._configuration.additionalModuleKindsToEmit) {
            for (const additionalModuleKindToEmit of this._configuration.additionalModuleKindsToEmit) {
                const moduleKind = this._parseModuleKind(ts, additionalModuleKindToEmit.moduleKind);
                const outDirKey = `${additionalModuleKindToEmit.outFolderName}:.js`;
                const moduleKindReason = {
                    kind: ts.ModuleKind[moduleKind],
                    outDir: additionalModuleKindToEmit.outFolderName,
                    extension: '.js',
                    reason: `additionalModuleKindsToEmit`
                };
                const existingKind = specifiedKinds.get(moduleKind);
                const existingDir = specifiedOutDirs.get(outDirKey);
                if (existingKind) {
                    throw new Error(`Module kind "${additionalModuleKindToEmit.moduleKind}" is already emitted at ${existingKind.outDir} with extension '${existingKind.extension}' by option ${existingKind.reason}.`);
                }
                else if (existingDir) {
                    throw new Error(`Output folder "${additionalModuleKindToEmit.outFolderName}" already contains module kind ${existingDir.kind} with extension '${existingDir.extension}', specified by option ${existingDir.reason}.`);
                }
                else {
                    const outFolderKey = this._addModuleKindToEmit(moduleKind, additionalModuleKindToEmit.outFolderName, 
                    /* isPrimary */ false, undefined);
                    if (outFolderKey) {
                        specifiedKinds.set(moduleKind, moduleKindReason);
                        specifiedOutDirs.set(outFolderKey, moduleKindReason);
                    }
                }
            }
        }
    }
    _addModuleKindToEmit(moduleKind, outFolderPath, isPrimary, jsExtensionOverride) {
        let outFolderName;
        if (path.isAbsolute(outFolderPath)) {
            outFolderName = path.relative(this._configuration.buildFolder, outFolderPath);
        }
        else {
            outFolderName = outFolderPath;
            outFolderPath = path.resolve(this._configuration.buildFolder, outFolderPath);
        }
        outFolderPath = node_core_library_1.Path.convertToSlashes(outFolderPath);
        outFolderPath = outFolderPath.replace(/\/*$/, '/'); // Ensure the outFolderPath ends with a slash
        for (const existingModuleKindToEmit of this._moduleKindsToEmit) {
            let errorText;
            if (existingModuleKindToEmit.outFolderPath === outFolderPath) {
                if (existingModuleKindToEmit.jsExtensionOverride === jsExtensionOverride) {
                    errorText =
                        'Unable to output two different module kinds with the same ' +
                            `module extension (${jsExtensionOverride || '.js'}) to the same ` +
                            `folder ("${outFolderPath}").`;
                }
            }
            else {
                let parentFolder;
                let childFolder;
                if (outFolderPath.startsWith(existingModuleKindToEmit.outFolderPath)) {
                    parentFolder = outFolderPath;
                    childFolder = existingModuleKindToEmit.outFolderPath;
                }
                else if (existingModuleKindToEmit.outFolderPath.startsWith(outFolderPath)) {
                    parentFolder = existingModuleKindToEmit.outFolderPath;
                    childFolder = outFolderPath;
                }
                if (parentFolder) {
                    errorText =
                        'Unable to output two different module kinds to nested folders ' +
                            `("${parentFolder}" and "${childFolder}").`;
                }
            }
            if (errorText) {
                this._typescriptLogger.emitError(new Error(errorText));
                return undefined;
            }
        }
        this._moduleKindsToEmit.push({
            outFolderPath,
            moduleKind,
            jsExtensionOverride,
            isPrimary
        });
        return `${outFolderName}:${jsExtensionOverride || '.js'}`;
    }
    _loadTsconfig(ts) {
        const parsedConfigFile = ts.readConfigFile(this._configuration.tsconfigPath, this._cachedFileSystem.readFile);
        const currentFolder = path.dirname(this._configuration.tsconfigPath);
        const tsconfig = ts.parseJsonConfigFileContent(parsedConfigFile.config, {
            fileExists: this._cachedFileSystem.exists,
            readFile: this._cachedFileSystem.readFile,
            readDirectory: (folderPath, extensions, excludes, includes, depth) => ts.matchFiles(folderPath, extensions, excludes, includes, 
            /* useCaseSensitiveFileNames */ true, currentFolder, depth, this._cachedFileSystem.readFolderFilesAndDirectories.bind(this._cachedFileSystem), this._cachedFileSystem.getRealPath.bind(this._cachedFileSystem), this._cachedFileSystem.directoryExists.bind(this._cachedFileSystem)),
            useCaseSensitiveFileNames: true
        }, currentFolder, 
        /*existingOptions:*/ undefined, this._configuration.tsconfigPath);
        if (tsconfig.options.incremental) {
            tsconfig.options.tsBuildInfoFile = this._tsCacheFilePath;
        }
        return tsconfig;
    }
    _buildSolutionBuilderHost(ts, reportDiagnostic) {
        const reportSolutionBuilderStatus = reportDiagnostic;
        const reportEmitErrorSummary = (errorCount) => {
            // Do nothing
        };
        const compilerHost = ts.createSolutionBuilderHost(this._getCachingTypeScriptSystem(ts), ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic, reportSolutionBuilderStatus, reportEmitErrorSummary);
        return compilerHost;
    }
    _buildIncrementalCompilerHost(ts, tsconfig) {
        if (tsconfig.options.incremental) {
            return ts.createIncrementalCompilerHost(tsconfig.options, this._getCachingTypeScriptSystem(ts));
        }
        else {
            return ts.createCompilerHost(tsconfig.options);
        }
    }
    _getCachingTypeScriptSystem(ts) {
        const sys = Object.assign(Object.assign({}, ts.sys), { deleteFile: this._cachedFileSystem.deleteFile.bind(this._cachedFileSystem), 
            /** Check if the path exists and is a directory */
            directoryExists: (directoryPath) => {
                try {
                    const stats = this._cachedFileSystem.getStatistics(directoryPath);
                    return stats.isDirectory() || stats.isSymbolicLink();
                }
                catch (error) {
                    if (node_core_library_1.FileSystem.isNotExistError(error)) {
                        return false;
                    }
                    else {
                        throw error;
                    }
                }
            }, 
            /** Check if the path exists and is a file */
            fileExists: (filePath) => {
                try {
                    const stats = this._cachedFileSystem.getStatistics(filePath);
                    return stats.isFile();
                }
                catch (error) {
                    if (node_core_library_1.FileSystem.isNotExistError(error)) {
                        return false;
                    }
                    else {
                        throw error;
                    }
                }
            }, 
            /* Use the Heft config's build folder because it has corrected casing */
            getCurrentDirectory: () => this._configuration.buildFolder, getDirectories: (folderPath) => {
                return this._cachedFileSystem.readFolderFilesAndDirectories(folderPath).directories;
            }, realpath: this._cachedFileSystem.getRealPath.bind(this._cachedFileSystem) });
        return sys;
    }
    _buildWatchCompilerHost(ts, tsconfig) {
        const reportDiagnostic = (diagnostic) => {
            this._printDiagnosticMessage(ts, diagnostic);
        };
        const reportWatchStatus = (diagnostic) => {
            this._printDiagnosticMessage(ts, diagnostic);
            // In watch mode, notify EmitCompletedCallbackManager every time we finish recompiling.
            if (diagnostic.code === ts.Diagnostics.Found_0_errors_Watching_for_file_changes.code ||
                diagnostic.code === ts.Diagnostics.Found_1_error_Watching_for_file_changes.code) {
                this._emitCompletedCallbackManager.callback();
            }
        };
        return ts.createWatchCompilerHost(tsconfig.fileNames, tsconfig.options, this._getCachingTypeScriptSystem(ts), ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic, reportWatchStatus, tsconfig.projectReferences);
    }
    _buildWatchSolutionBuilderHost(ts) {
        const reportDiagnostic = (diagnostic) => {
            this._printDiagnosticMessage(ts, diagnostic);
        };
        const reportSolutionBuilderStatus = reportDiagnostic;
        const reportWatchStatus = (diagnostic) => {
            this._printDiagnosticMessage(ts, diagnostic);
            // In watch mode, notify EmitCompletedCallbackManager every time we finish recompiling.
            if (diagnostic.code === ts.Diagnostics.Found_0_errors_Watching_for_file_changes.code ||
                diagnostic.code === ts.Diagnostics.Found_1_error_Watching_for_file_changes.code) {
                this._emitCompletedCallbackManager.callback();
            }
        };
        return ts.createSolutionBuilderWithWatchHost(this._getCachingTypeScriptSystem(ts), ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic, reportSolutionBuilderStatus, reportWatchStatus);
    }
    _overrideTypeScriptReadJson(ts) {
        ts.readJson = (filePath) => {
            let jsonData = this._tsReadJsonCache.get(filePath);
            if (jsonData) {
                return jsonData;
            }
            else {
                try {
                    const fileContents = this._cachedFileSystem.readFile(filePath);
                    if (!fileContents) {
                        jsonData = EMPTY_JSON;
                    }
                    else {
                        const parsedFile = ts.parseConfigFileTextToJson(filePath, fileContents);
                        if (parsedFile.error) {
                            jsonData = EMPTY_JSON;
                        }
                        else {
                            jsonData = parsedFile.config;
                        }
                    }
                }
                catch (error) {
                    jsonData = EMPTY_JSON;
                }
                this._tsReadJsonCache.set(filePath, jsonData);
                return jsonData;
            }
        };
    }
    _parseModuleKind(ts, moduleKindName) {
        switch (moduleKindName.toLowerCase()) {
            case 'commonjs':
                return ts.ModuleKind.CommonJS;
            case 'amd':
                return ts.ModuleKind.AMD;
            case 'umd':
                return ts.ModuleKind.UMD;
            case 'system':
                return ts.ModuleKind.System;
            case 'es2015':
                return ts.ModuleKind.ES2015;
            case 'esnext':
                return ts.ModuleKind.ESNext;
            default:
                throw new Error(`"${moduleKindName}" is not a valid module kind name.`);
        }
    }
}
exports.TypeScriptBuilder = TypeScriptBuilder;
//# sourceMappingURL=TypeScriptBuilder.js.map