{"version":3,"file":"HeftCommandLine.js","sourceRoot":"","sources":["../../src/cli/HeftCommandLine.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  IBaseCommandLineDefinition,\n  ICommandLineFlagDefinition,\n  ICommandLineIntegerDefinition,\n  ICommandLineStringDefinition,\n  ICommandLineStringListDefinition,\n  ICommandLineChoiceDefinition,\n  ICommandLineChoiceListDefinition,\n  CommandLineAction,\n  CommandLineParser,\n  CommandLineFlagParameter,\n  CommandLineIntegerParameter,\n  CommandLineStringParameter,\n  CommandLineStringListParameter,\n  CommandLineChoiceParameter,\n  CommandLineChoiceListParameter,\n  CommandLineParameter\n} from '@rushstack/ts-command-line';\nimport { ITerminal } from '@rushstack/node-core-library';\n\n/**\n * @beta\n * The base set of utility values provided in every object returned when registering a parameter.\n */\nexport interface IHeftBaseParameter<TValue, TCommandLineDefinition extends IBaseCommandLineDefinition> {\n  /**\n   * The value specified on the command line for this parameter.\n   */\n  readonly value?: TValue;\n\n  /**\n   * If true, then the user has invoked Heft with a command line action that supports this parameter\n   * (as defined by the {@link IParameterAssociatedActionNames.associatedActionNames} option).\n   *\n   * @remarks\n   * For example, if `build` is one of the associated action names for `--my-integer-parameter`,\n   * then `actionAssociated` will be true if the user invokes `heft build`.\n   *\n   * To test whether the parameter was actually included (e.g. `heft build --my-integer-parameter 123`),\n   * verify the {@link IHeftBaseParameter.value} property is not `undefined`.\n   */\n  readonly actionAssociated: boolean;\n\n  /**\n   * The options {@link IHeftRegisterParameterOptions} used to create and register the parameter with\n   * a Heft command line action.\n   */\n  readonly definition: IHeftRegisterParameterOptions<TCommandLineDefinition>;\n}\n\n/**\n * @beta\n * The object returned when registering a choice type parameter.\n */\nexport type IHeftChoiceParameter = IHeftBaseParameter<string, ICommandLineChoiceDefinition>;\n\n/**\n * @beta\n * The object returned when registering a choiceList type parameter.\n */\nexport type IHeftChoiceListParameter = IHeftBaseParameter<\n  readonly string[],\n  ICommandLineChoiceListDefinition\n>;\n\n/**\n * @beta\n * The object returned when registering a flag type parameter.\n */\nexport type IHeftFlagParameter = IHeftBaseParameter<boolean, ICommandLineFlagDefinition>;\n\n/**\n * @beta\n * The object returned when registering an integer type parameter.\n */\nexport type IHeftIntegerParameter = IHeftBaseParameter<number, ICommandLineIntegerDefinition>;\n\n/**\n * @beta\n * The object returned when registering a string type parameter.\n */\nexport type IHeftStringParameter = IHeftBaseParameter<string, ICommandLineStringDefinition>;\n\n/**\n * @beta\n * The object returned when registering a stringList type parameter.\n */\nexport type IHeftStringListParameter = IHeftBaseParameter<\n  readonly string[],\n  ICommandLineStringListDefinition\n>;\n\n/**\n * @beta\n * The configuration interface for associating a parameter definition with a Heft\n * command line action in {@link IHeftRegisterParameterOptions}.\n */\nexport interface IParameterAssociatedActionNames {\n  /**\n   * A string list of one or more action names to associate the parameter with.\n   */\n  associatedActionNames: string[];\n}\n\n/**\n * @beta\n * The options object provided to the command line parser when registering a parameter\n * in addition to the action names used to associate the parameter with.\n */\nexport type IHeftRegisterParameterOptions<TCommandLineDefinition extends IBaseCommandLineDefinition> =\n  TCommandLineDefinition & IParameterAssociatedActionNames;\n\n/**\n * @beta\n * Command line utilities provided for Heft plugin developers.\n */\nexport class HeftCommandLine {\n  private readonly _commandLineParser: CommandLineParser;\n  private readonly _terminal: ITerminal;\n\n  /**\n   * @internal\n   */\n  public constructor(commandLineParser: CommandLineParser, terminal: ITerminal) {\n    this._commandLineParser = commandLineParser;\n    this._terminal = terminal;\n  }\n\n  /**\n   * Utility method used by Heft plugins to register a choice type parameter.\n   */\n  public registerChoiceParameter(\n    options: IHeftRegisterParameterOptions<ICommandLineChoiceDefinition>\n  ): IHeftChoiceParameter {\n    return this._registerParameter(\n      options,\n      (action: CommandLineAction) => action.defineChoiceParameter(options),\n      (parameter: CommandLineChoiceParameter) => parameter.value\n    );\n  }\n\n  /**\n   * Utility method used by Heft plugins to register a choiceList type parameter.\n   */\n  public registerChoiceListParameter(\n    options: IHeftRegisterParameterOptions<ICommandLineChoiceListDefinition>\n  ): IHeftChoiceListParameter {\n    return this._registerParameter(\n      options,\n      (action: CommandLineAction) => action.defineChoiceListParameter(options),\n      (parameter: CommandLineChoiceListParameter) => parameter.values\n    );\n  }\n\n  /**\n   * Utility method used by Heft plugins to register a flag type parameter.\n   */\n  public registerFlagParameter(\n    options: IHeftRegisterParameterOptions<ICommandLineFlagDefinition>\n  ): IHeftFlagParameter {\n    return this._registerParameter(\n      options,\n      (action: CommandLineAction) => action.defineFlagParameter(options),\n      (parameter: CommandLineFlagParameter) => parameter.value\n    );\n  }\n\n  /**\n   * Utility method used by Heft plugins to register an integer type parameter.\n   */\n  public registerIntegerParameter(\n    options: IHeftRegisterParameterOptions<ICommandLineIntegerDefinition>\n  ): IHeftIntegerParameter {\n    return this._registerParameter(\n      options,\n      (action: CommandLineAction) => action.defineIntegerParameter(options),\n      (parameter: CommandLineIntegerParameter) => parameter.value\n    );\n  }\n\n  /**\n   * Utility method used by Heft plugins to register a string type parameter.\n   */\n  public registerStringParameter(\n    options: IHeftRegisterParameterOptions<ICommandLineStringDefinition>\n  ): IHeftStringParameter {\n    return this._registerParameter(\n      options,\n      (action: CommandLineAction) => action.defineStringParameter(options),\n      (parameter: CommandLineStringParameter) => parameter.value\n    );\n  }\n\n  /**\n   * Utility method used by Heft plugins to register a stringList type parameter.\n   */\n  public registerStringListParameter(\n    options: IHeftRegisterParameterOptions<ICommandLineStringListDefinition>\n  ): IHeftStringListParameter {\n    return this._registerParameter(\n      options,\n      (action: CommandLineAction) => action.defineStringListParameter(options),\n      (parameter: CommandLineStringListParameter) => parameter.values\n    );\n  }\n\n  private _registerParameter<\n    TCommandLineDefinition extends IBaseCommandLineDefinition,\n    TCommandLineParameter extends CommandLineParameter,\n    TValue\n  >(\n    options: IHeftRegisterParameterOptions<TCommandLineDefinition>,\n    defineParameterForAction: (action: CommandLineAction) => TCommandLineParameter,\n    getParameterValue: (parameter: TCommandLineParameter) => TValue | undefined\n  ): IHeftBaseParameter<TValue, TCommandLineDefinition> {\n    const actionParameterMap: Map<CommandLineAction, TCommandLineParameter> = new Map();\n    for (const action of this._getActions(options.associatedActionNames, options.parameterLongName)) {\n      this._verifyUniqueParameterName(action, options);\n      const parameter: TCommandLineParameter = defineParameterForAction(action);\n      actionParameterMap.set(action, parameter);\n    }\n\n    const parameterObject: IHeftBaseParameter<TValue, TCommandLineDefinition> = Object.defineProperties(\n      {} as IHeftBaseParameter<TValue, TCommandLineDefinition>,\n      {\n        value: {\n          get: (): TValue | undefined => {\n            this._verifyParametersProcessed(options.parameterLongName);\n            if (this._commandLineParser.selectedAction) {\n              const parameter: TCommandLineParameter | undefined = actionParameterMap.get(\n                this._commandLineParser.selectedAction\n              );\n              if (parameter) {\n                return getParameterValue(parameter);\n              }\n            }\n\n            return undefined;\n          }\n        },\n\n        actionAssociated: {\n          get: (): boolean => {\n            if (!this._commandLineParser.selectedAction) {\n              throw new Error('Unable to determine the selected action prior to command line processing');\n            }\n            if (actionParameterMap.get(this._commandLineParser.selectedAction)) {\n              return true;\n            }\n            return false;\n          }\n        },\n\n        definition: {\n          get: (): IHeftRegisterParameterOptions<TCommandLineDefinition> => {\n            return { ...options };\n          }\n        }\n      }\n    );\n\n    return parameterObject;\n  }\n\n  private _getActions(actionNames: string[], parameterLongName: string): CommandLineAction[] {\n    const actions: CommandLineAction[] = [];\n    for (const actionName of actionNames) {\n      const action: CommandLineAction | undefined = this._commandLineParser.tryGetAction(actionName);\n      if (action) {\n        if (action.parametersProcessed) {\n          throw new Error(\n            `Unable to register parameter \"${parameterLongName}\" for action \"${action.actionName}\". ` +\n              'Parameters have already been processed.'\n          );\n        }\n        actions.push(action);\n      } else {\n        this._terminal.writeVerboseLine(\n          `Unable to find action \"${actionName}\" while registering the \"${parameterLongName}\" parameter`\n        );\n      }\n    }\n    return actions;\n  }\n\n  private _verifyUniqueParameterName<TCommandLineDefinition extends IBaseCommandLineDefinition>(\n    action: CommandLineAction,\n    options: IHeftRegisterParameterOptions<TCommandLineDefinition>\n  ): void {\n    const existingParameterLongNames: Set<string> = new Set(\n      action.parameters.map((parameter) => parameter.longName)\n    );\n\n    if (existingParameterLongNames.has(options.parameterLongName)) {\n      throw new Error(`Attempting to register duplicate parameter long name: ${options.parameterLongName}`);\n    }\n\n    if (options.parameterShortName) {\n      const existingParameterShortNames: Set<string | undefined> = new Set(\n        action.parameters.map((parameter) => parameter.shortName)\n      );\n      if (existingParameterShortNames.has(options.parameterShortName)) {\n        throw new Error(\n          `Attempting to register duplicate parameter short name: ${options.parameterShortName}`\n        );\n      }\n    }\n  }\n\n  private _verifyParametersProcessed(parameterName: string): void {\n    if (!this._commandLineParser.parametersProcessed) {\n      throw new Error(\n        `Unable to access parameter value for \"${parameterName}\" prior to command line processing`\n      );\n    }\n  }\n}\n"]}