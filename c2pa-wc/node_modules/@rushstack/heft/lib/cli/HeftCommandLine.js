"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeftCommandLine = void 0;
/**
 * @beta
 * Command line utilities provided for Heft plugin developers.
 */
class HeftCommandLine {
    /**
     * @internal
     */
    constructor(commandLineParser, terminal) {
        this._commandLineParser = commandLineParser;
        this._terminal = terminal;
    }
    /**
     * Utility method used by Heft plugins to register a choice type parameter.
     */
    registerChoiceParameter(options) {
        return this._registerParameter(options, (action) => action.defineChoiceParameter(options), (parameter) => parameter.value);
    }
    /**
     * Utility method used by Heft plugins to register a choiceList type parameter.
     */
    registerChoiceListParameter(options) {
        return this._registerParameter(options, (action) => action.defineChoiceListParameter(options), (parameter) => parameter.values);
    }
    /**
     * Utility method used by Heft plugins to register a flag type parameter.
     */
    registerFlagParameter(options) {
        return this._registerParameter(options, (action) => action.defineFlagParameter(options), (parameter) => parameter.value);
    }
    /**
     * Utility method used by Heft plugins to register an integer type parameter.
     */
    registerIntegerParameter(options) {
        return this._registerParameter(options, (action) => action.defineIntegerParameter(options), (parameter) => parameter.value);
    }
    /**
     * Utility method used by Heft plugins to register a string type parameter.
     */
    registerStringParameter(options) {
        return this._registerParameter(options, (action) => action.defineStringParameter(options), (parameter) => parameter.value);
    }
    /**
     * Utility method used by Heft plugins to register a stringList type parameter.
     */
    registerStringListParameter(options) {
        return this._registerParameter(options, (action) => action.defineStringListParameter(options), (parameter) => parameter.values);
    }
    _registerParameter(options, defineParameterForAction, getParameterValue) {
        const actionParameterMap = new Map();
        for (const action of this._getActions(options.associatedActionNames, options.parameterLongName)) {
            this._verifyUniqueParameterName(action, options);
            const parameter = defineParameterForAction(action);
            actionParameterMap.set(action, parameter);
        }
        const parameterObject = Object.defineProperties({}, {
            value: {
                get: () => {
                    this._verifyParametersProcessed(options.parameterLongName);
                    if (this._commandLineParser.selectedAction) {
                        const parameter = actionParameterMap.get(this._commandLineParser.selectedAction);
                        if (parameter) {
                            return getParameterValue(parameter);
                        }
                    }
                    return undefined;
                }
            },
            actionAssociated: {
                get: () => {
                    if (!this._commandLineParser.selectedAction) {
                        throw new Error('Unable to determine the selected action prior to command line processing');
                    }
                    if (actionParameterMap.get(this._commandLineParser.selectedAction)) {
                        return true;
                    }
                    return false;
                }
            },
            definition: {
                get: () => {
                    return Object.assign({}, options);
                }
            }
        });
        return parameterObject;
    }
    _getActions(actionNames, parameterLongName) {
        const actions = [];
        for (const actionName of actionNames) {
            const action = this._commandLineParser.tryGetAction(actionName);
            if (action) {
                if (action.parametersProcessed) {
                    throw new Error(`Unable to register parameter "${parameterLongName}" for action "${action.actionName}". ` +
                        'Parameters have already been processed.');
                }
                actions.push(action);
            }
            else {
                this._terminal.writeVerboseLine(`Unable to find action "${actionName}" while registering the "${parameterLongName}" parameter`);
            }
        }
        return actions;
    }
    _verifyUniqueParameterName(action, options) {
        const existingParameterLongNames = new Set(action.parameters.map((parameter) => parameter.longName));
        if (existingParameterLongNames.has(options.parameterLongName)) {
            throw new Error(`Attempting to register duplicate parameter long name: ${options.parameterLongName}`);
        }
        if (options.parameterShortName) {
            const existingParameterShortNames = new Set(action.parameters.map((parameter) => parameter.shortName));
            if (existingParameterShortNames.has(options.parameterShortName)) {
                throw new Error(`Attempting to register duplicate parameter short name: ${options.parameterShortName}`);
            }
        }
    }
    _verifyParametersProcessed(parameterName) {
        if (!this._commandLineParser.parametersProcessed) {
            throw new Error(`Unable to access parameter value for "${parameterName}" prior to command line processing`);
        }
    }
}
exports.HeftCommandLine = HeftCommandLine;
//# sourceMappingURL=HeftCommandLine.js.map