"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestAction = void 0;
const BuildAction_1 = require("./BuildAction");
const Logging_1 = require("../../utilities/Logging");
class TestAction extends BuildAction_1.BuildAction {
    /*
    // Temporary workaround for https://github.com/microsoft/rushstack/issues/2759
    private _passWithNoTests!: CommandLineFlagParameter;
    */
    constructor(heftActionOptions) {
        super(heftActionOptions, {
            actionName: 'test',
            summary: 'Build the project and run tests.',
            documentation: ''
        });
    }
    onDefineParameters() {
        super.onDefineParameters();
        this._noTestFlag = this.defineFlagParameter({
            parameterLongName: '--no-test',
            description: 'If specified, run the build without testing.',
            undocumentedSynonyms: ['--notest'] // To be removed
        });
        this._noBuildFlag = this.defineFlagParameter({
            parameterLongName: '--no-build',
            description: 'If provided, only run tests. Do not build first.'
        });
    }
    async actionExecuteAsync() {
        const shouldBuild = !this._noBuildFlag.value;
        const watchMode = this._watchFlag.value;
        const noTest = this._noTestFlag.value;
        const lite = this._liteFlag.value;
        if (watchMode) {
            if (!shouldBuild) {
                throw new Error(`${this._watchFlag.longName} is not compatible with ${this._noBuildFlag.longName}`);
            }
            else if (noTest) {
                throw new Error(`${this._watchFlag.longName} is not compatible with ${this._noTestFlag.longName}`);
            }
            else if (lite) {
                throw new Error(`${this._watchFlag.longName} is not compatible with ${this._liteFlag.longName}`);
            }
        }
        if (!shouldBuild) {
            if (noTest) {
                throw new Error(`${this._noTestFlag.longName} is not compatible with ${this._noBuildFlag.longName}`);
            }
        }
        if (noTest || lite /* "&& shouldBuild" is implied */) {
            await super.actionExecuteAsync();
        }
        else {
            const testStage = this.stages.testStage;
            const testStageOptions = {
                watchMode: this._watchFlag.value
            };
            await testStage.initializeAsync(testStageOptions);
            if (shouldBuild) {
                await super.actionExecuteAsync();
                if (this.loggingManager.errorsHaveBeenEmitted &&
                    !watchMode // Kick off tests in --watch mode
                ) {
                    return;
                }
                await Logging_1.Logging.runFunctionWithLoggingBoundsAsync(this.terminal, 'Test', async () => await testStage.executeAsync());
            }
            else {
                await testStage.executeAsync();
            }
        }
    }
}
exports.TestAction = TestAction;
//# sourceMappingURL=TestAction.js.map