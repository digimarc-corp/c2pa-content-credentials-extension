{"version":3,"file":"TypeScriptCachedFileSystem.js","sourceRoot":"","sources":["../../../src/utilities/fileSystem/TypeScriptCachedFileSystem.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport {\n  Encoding,\n  Text,\n  IFileSystemWriteFileOptions,\n  IFileSystemReadFileOptions,\n  IFileSystemCopyFileOptions,\n  IFileSystemDeleteFileOptions,\n  IFileSystemCreateLinkOptions,\n  FileSystem,\n  FileSystemStats,\n  Sort,\n  FolderItem\n} from '@rushstack/node-core-library';\n\nexport interface IReadFolderFilesAndDirectoriesResult {\n  files: string[];\n  directories: string[];\n}\n\ninterface ICacheEntry<TEntry> {\n  entry: TEntry | undefined;\n  error?: NodeJS.ErrnoException;\n}\n\n/**\n * This is a FileSystem API (largely unrelated to the @rushstack/node-core-library FileSystem API)\n * that provides caching to the Heft TypeScriptBuilder.\n * It uses an in-memory cache to avoid requests against the disk. It assumes that the disk stays\n * static after construction, except for writes performed through the TypeScriptCachedFileSystem\n * instance.\n */\nexport class TypeScriptCachedFileSystem {\n  private _statsCache: Map<string, ICacheEntry<FileSystemStats>> = new Map();\n  private _readFolderCache: Map<string, ICacheEntry<IReadFolderFilesAndDirectoriesResult>> = new Map();\n  private _readFileCache: Map<string, ICacheEntry<Buffer>> = new Map();\n  private _realPathCache: Map<string, ICacheEntry<string>> = new Map();\n\n  public exists: (path: string) => boolean = (path: string) => {\n    try {\n      this.getStatistics(path);\n      return true;\n    } catch (e) {\n      if (FileSystem.isNotExistError(e as Error)) {\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  };\n\n  public directoryExists: (path: string) => boolean = (path: string) => {\n    try {\n      const stats: FileSystemStats = this.getStatistics(path);\n      return stats.isDirectory();\n    } catch (e) {\n      if (FileSystem.isNotExistError(e as Error)) {\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  };\n\n  public getStatistics: (path: string) => FileSystemStats = (path: string) => {\n    return this._withCaching(path, FileSystem.getStatistics, this._statsCache);\n  };\n\n  public ensureFolder: (folderPath: string) => void = (folderPath: string) => {\n    if (!this._readFolderCache.get(folderPath)?.entry && !this._statsCache.get(folderPath)?.entry) {\n      FileSystem.ensureFolder(folderPath);\n      this._invalidateCacheEntry(folderPath);\n    }\n  };\n\n  public ensureFolderAsync: (folderPath: string) => Promise<void> = async (folderPath: string) => {\n    if (!this._readFolderCache.get(folderPath)?.entry && !this._statsCache.get(folderPath)?.entry) {\n      await FileSystem.ensureFolderAsync(folderPath);\n      this._invalidateCacheEntry(folderPath);\n    }\n  };\n\n  public writeFile: (\n    filePath: string,\n    contents: string | Buffer,\n    options?: IFileSystemWriteFileOptions | undefined\n  ) => void = (\n    filePath: string,\n    contents: string | Buffer,\n    options?: IFileSystemWriteFileOptions | undefined\n  ) => {\n    FileSystem.writeFile(filePath, contents, options);\n    this._invalidateCacheEntry(filePath);\n  };\n\n  public readFile: (filePath: string, options?: IFileSystemReadFileOptions | undefined) => string = (\n    filePath: string,\n    options?: IFileSystemReadFileOptions | undefined\n  ) => {\n    let contents: string = this.readFileToBuffer(filePath).toString(options?.encoding || Encoding.Utf8);\n    if (options?.convertLineEndings) {\n      contents = Text.convertTo(contents, options.convertLineEndings);\n    }\n\n    return contents;\n  };\n\n  public readFileToBuffer: (filePath: string) => Buffer = (filePath: string) => {\n    return this._withCaching(filePath, FileSystem.readFileToBuffer, this._readFileCache);\n  };\n\n  public copyFileAsync: (options: IFileSystemCopyFileOptions) => Promise<void> = async (\n    options: IFileSystemCopyFileOptions\n  ) => {\n    await FileSystem.copyFileAsync(options);\n    this._invalidateCacheEntry(options.destinationPath);\n  };\n\n  public deleteFile: (filePath: string, options?: IFileSystemDeleteFileOptions | undefined) => void = (\n    filePath: string,\n    options?: IFileSystemDeleteFileOptions | undefined\n  ) => {\n    const cachedError: Error | undefined = this._statsCache.get(filePath)?.error;\n    if (!cachedError || !FileSystem.isFileDoesNotExistError(cachedError)) {\n      FileSystem.deleteFile(filePath);\n      this._invalidateCacheEntry(filePath);\n    } else if (options?.throwIfNotExists) {\n      throw cachedError;\n    }\n  };\n\n  public createHardLinkAsync: (options: IFileSystemCreateLinkOptions) => Promise<void> = async (\n    options: IFileSystemCreateLinkOptions\n  ) => {\n    await FileSystem.createHardLinkAsync(options);\n    this._invalidateCacheEntry(options.newLinkPath);\n  };\n\n  public getRealPath: (linkPath: string) => string = (linkPath: string) => {\n    return this._withCaching(\n      linkPath,\n      (linkPath: string) => {\n        try {\n          return FileSystem.getRealPath(linkPath);\n        } catch (e) {\n          if (FileSystem.isNotExistError(e as Error)) {\n            // TypeScript's ts.sys.realpath returns the path it's provided if that path doesn't exist\n            return linkPath;\n          } else {\n            throw e;\n          }\n        }\n      },\n      this._realPathCache\n    );\n  };\n\n  public readFolderFilesAndDirectories: (folderPath: string) => IReadFolderFilesAndDirectoriesResult = (\n    folderPath: string\n  ) => {\n    return this._withCaching(\n      folderPath,\n      (path: string) => {\n        const folderEntries: FolderItem[] = FileSystem.readFolderItems(path);\n        return this._sortFolderEntries(folderEntries);\n      },\n      this._readFolderCache\n    );\n  };\n\n  private _sortFolderEntries(folderEntries: FolderItem[]): IReadFolderFilesAndDirectoriesResult {\n    // TypeScript expects entries sorted ordinally by name\n    // In practice this might not matter\n    folderEntries.sort((a, b) => Sort.compareByValue(a, b));\n\n    const files: string[] = [];\n    const directories: string[] = [];\n    for (const folderEntry of folderEntries) {\n      if (folderEntry.isFile()) {\n        files.push(folderEntry.name);\n      } else if (folderEntry.isDirectory()) {\n        directories.push(folderEntry.name);\n      }\n    }\n\n    return { files, directories };\n  }\n\n  private _withCaching<TResult>(\n    path: string,\n    fn: (path: string) => TResult,\n    cache: Map<string, ICacheEntry<TResult>>\n  ): TResult {\n    let cacheEntry: ICacheEntry<TResult> | undefined = cache.get(path);\n    if (!cacheEntry) {\n      try {\n        cacheEntry = { entry: fn(path) };\n      } catch (e) {\n        cacheEntry = { error: e as Error, entry: undefined };\n      }\n\n      cache.set(path, cacheEntry);\n    }\n\n    if (cacheEntry.entry) {\n      return cacheEntry.entry;\n    } else {\n      throw cacheEntry.error;\n    }\n  }\n\n  private _invalidateCacheEntry(path: string): void {\n    this._statsCache.delete(path);\n    this._readFolderCache.delete(path);\n    this._readFileCache.delete(path);\n    this._realPathCache.delete(path);\n  }\n}\n"]}