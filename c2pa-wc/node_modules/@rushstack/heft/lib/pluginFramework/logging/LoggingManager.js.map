{"version":3,"file":"LoggingManager.js","sourceRoot":"","sources":["../../../src/pluginFramework/logging/LoggingManager.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAG3D,iDAA8C;AAC9C,oEAKsC;AAMtC,MAAa,cAAc;IAUzB,YAAmB,OAA+B;QAR1C,mBAAc,GAA8B,IAAI,GAAG,EAAwB,CAAC;QAC5E,uBAAkB,GAAY,KAAK,CAAC;QACpC,kBAAa,GAAY,KAAK,CAAC;QAOrC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAND,IAAW,qBAAqB;QAC9B,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAMM,iBAAiB;QACtB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;IACjC,CAAC;IAEM,mBAAmB,CAAC,MAAmB,EAAE,UAAkB;QAChE,MAAM,oBAAoB,GAA6B,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAC3F,IAAI,oBAAoB,EAAE;YACxB,MAAM,IAAI,KAAK,CACb,6BAA6B,UAAU,+BAA+B;gBACpE,cAAc,oBAAoB,CAAC,iBAAiB,CAAC,UAAU,IAAI,CACtE,CAAC;SACH;aAAM;YACL,MAAM,YAAY,GAAiB,IAAI,2BAAY,CAAC;gBAClD,gBAAgB,EAAE,MAAM;gBACxB,UAAU;gBACV,gBAAgB,EAAE,IAAI,CAAC,QAAQ,CAAC,gBAAgB;gBAChD,oBAAoB,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,kBAAkB;gBACnD,2BAA2B,EAAE,GAAG,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;aAC/D,CAAC,CAAC;YACH,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;YAClD,OAAO,YAAY,CAAC;SACrB;IACH,CAAC;IAEM,eAAe,CAAC,iBAAqC;QAC1D,MAAM,MAAM,GAAa,EAAE,CAAC;QAE5B,KAAK,MAAM,YAAY,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,EAAE;YACvD,MAAM,CAAC,IAAI,CACT,GAAG,YAAY,CAAC,MAAM,CAAC,GAAG,CACxB,CAAC,KAAK,EAAE,EAAE,CACR,IAAI,YAAY,CAAC,UAAU,IAAI;gBAC/B,cAAc,CAAC,eAAe,CAAC,KAAK,EAAE,EAAE,MAAM,EAAE,iBAAiB,EAAE,CAAC,CACvE,CACF,CAAC;SACH;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,iBAAiB,CAAC,eAAmC;QAC1D,MAAM,MAAM,GAAa,EAAE,CAAC;QAE5B,KAAK,MAAM,YAAY,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,EAAE;YACvD,MAAM,CAAC,IAAI,CACT,GAAG,YAAY,CAAC,QAAQ,CAAC,GAAG,CAC1B,CAAC,OAAO,EAAE,EAAE,CACV,IAAI,YAAY,CAAC,UAAU,IAAI;gBAC/B,cAAc,CAAC,eAAe,CAAC,OAAO,EAAE,EAAE,MAAM,EAAE,eAAe,EAAE,CAAC,CACvE,CACF,CAAC;SACH;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,MAAM,CAAC,eAAe,CAAC,KAAY,EAAE,OAAqC;QAC/E,IAAI,KAAK,YAAY,6BAAS,EAAE;YAC9B,OAAO,KAAK,CAAC,wBAAwB,CAAC,OAAO,CAAC,CAAC;SAChD;aAAM;YACL,OAAO,KAAK,CAAC,OAAO,CAAC;SACtB;IACH,CAAC;CACF;AA7ED,wCA6EC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { IHeftPlugin } from '../IHeftPlugin';\nimport { ScopedLogger } from './ScopedLogger';\nimport {\n  FileError,\n  FileLocationStyle,\n  ITerminalProvider,\n  IFileErrorFormattingOptions\n} from '@rushstack/node-core-library';\n\nexport interface ILoggingManagerOptions {\n  terminalProvider: ITerminalProvider;\n}\n\nexport class LoggingManager {\n  private _options: ILoggingManagerOptions;\n  private _scopedLoggers: Map<string, ScopedLogger> = new Map<string, ScopedLogger>();\n  private _shouldPrintStacks: boolean = false;\n  private _hasAnyErrors: boolean = false;\n\n  public get errorsHaveBeenEmitted(): boolean {\n    return this._hasAnyErrors;\n  }\n\n  public constructor(options: ILoggingManagerOptions) {\n    this._options = options;\n  }\n\n  public enablePrintStacks(): void {\n    this._shouldPrintStacks = true;\n  }\n\n  public requestScopedLogger(plugin: IHeftPlugin, loggerName: string): ScopedLogger {\n    const existingScopedLogger: ScopedLogger | undefined = this._scopedLoggers.get(loggerName);\n    if (existingScopedLogger) {\n      throw new Error(\n        `A named logger with name \"${loggerName}\" has already been requested ` +\n          `by plugin \"${existingScopedLogger._requestingPlugin.pluginName}\".`\n      );\n    } else {\n      const scopedLogger: ScopedLogger = new ScopedLogger({\n        requestingPlugin: plugin,\n        loggerName,\n        terminalProvider: this._options.terminalProvider,\n        getShouldPrintStacks: () => this._shouldPrintStacks,\n        errorHasBeenEmittedCallback: () => (this._hasAnyErrors = true)\n      });\n      this._scopedLoggers.set(loggerName, scopedLogger);\n      return scopedLogger;\n    }\n  }\n\n  public getErrorStrings(fileLocationStyle?: FileLocationStyle): string[] {\n    const result: string[] = [];\n\n    for (const scopedLogger of this._scopedLoggers.values()) {\n      result.push(\n        ...scopedLogger.errors.map(\n          (error) =>\n            `[${scopedLogger.loggerName}] ` +\n            LoggingManager.getErrorMessage(error, { format: fileLocationStyle })\n        )\n      );\n    }\n\n    return result;\n  }\n\n  public getWarningStrings(fileErrorFormat?: FileLocationStyle): string[] {\n    const result: string[] = [];\n\n    for (const scopedLogger of this._scopedLoggers.values()) {\n      result.push(\n        ...scopedLogger.warnings.map(\n          (warning) =>\n            `[${scopedLogger.loggerName}] ` +\n            LoggingManager.getErrorMessage(warning, { format: fileErrorFormat })\n        )\n      );\n    }\n\n    return result;\n  }\n\n  public static getErrorMessage(error: Error, options?: IFileErrorFormattingOptions): string {\n    if (error instanceof FileError) {\n      return error.getFormattedErrorMessage(options);\n    } else {\n      return error.message;\n    }\n  }\n}\n"]}