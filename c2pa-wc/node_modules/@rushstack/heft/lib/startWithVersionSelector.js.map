{"version":3,"file":"startWithVersionSelector.js","sourceRoot":"","sources":["../src/startWithVersionSelector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n// NOTE: Since startWithVersionSelector.ts is loaded in the same process as start.ts, any dependencies that\n// we import here may become side-by-side versions.  We want to minimize any dependencies.\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport type { IPackageJson } from '@rushstack/node-core-library';\n\nconst HEFT_PACKAGE_NAME: string = '@rushstack/heft';\n\n// Excerpted from PackageJsonLookup.tryGetPackageFolderFor()\nfunction tryGetPackageFolderFor(resolvedFileOrFolderPath: string): string | undefined {\n  // Two lookups are required, because get() cannot distinguish the undefined value\n  // versus a missing key.\n  // if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {\n  //   return this._packageFolderCache.get(resolvedFileOrFolderPath);\n  // }\n\n  // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.\n  if (fs.existsSync(path.join(resolvedFileOrFolderPath, 'package.json'))) {\n    // this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);\n    return resolvedFileOrFolderPath;\n  }\n\n  // Otherwise go up one level\n  const parentFolder: string | undefined = path.dirname(resolvedFileOrFolderPath);\n  if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {\n    // We reached the root directory without finding a package.json file,\n    // so cache the negative result\n    // this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);\n    return undefined; // no match\n  }\n\n  // Recurse upwards, caching every step along the way\n  const parentResult: string | undefined = tryGetPackageFolderFor(parentFolder);\n  // Cache the parent's answer as well\n  // this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);\n\n  return parentResult;\n}\n\n/**\n * When Heft is invoked via the shell path, we examine the project's package.json dependencies and try to load\n * the locally installed version of Heft. This avoids accidentally building using the wrong version of Heft.\n * Use \"heft --unmanaged\" to bypass this feature.\n */\nfunction tryStartLocalHeft(): boolean {\n  if (process.argv.indexOf('--unmanaged') >= 0) {\n    console.log('(Bypassing the Heft version selector because \"--unmanaged\" was specified.)');\n    console.log();\n    return false;\n  } else if (process.argv.indexOf('--debug') >= 0) {\n    // The unmanaged flag could be undiscoverable if it's not in their locally installed version\n    console.log(\n      'Searching for a locally installed version of Heft. Use the --unmanaged flag if you want to avoid this'\n    );\n  }\n\n  // Find the package.json file that governs the current folder location\n  const projectFolder: string | undefined = tryGetPackageFolderFor(process.cwd());\n  if (projectFolder) {\n    let heftEntryPoint: string;\n    try {\n      const packageJsonPath: string = path.join(projectFolder, 'package.json');\n      const packageJsonContent: string = fs.readFileSync(packageJsonPath).toString();\n      let packageJson: IPackageJson;\n      try {\n        packageJson = JSON.parse(packageJsonContent);\n      } catch (error) {\n        throw new Error(`Error parsing ${packageJsonPath}:` + (error as Error).message);\n      }\n\n      // Does package.json have a dependency on Heft?\n      if (\n        !(packageJson.dependencies && packageJson.dependencies[HEFT_PACKAGE_NAME]) &&\n        !(packageJson.devDependencies && packageJson.devDependencies[HEFT_PACKAGE_NAME])\n      ) {\n        // No explicit dependency on Heft\n        return false;\n      }\n\n      // To avoid a loading the \"resolve\" NPM package, let's assume that the Heft dependency must be\n      // installed as \"<projectFolder>/node_modules/@rushstack/heft\".\n      const heftFolder: string = path.join(projectFolder, 'node_modules', HEFT_PACKAGE_NAME);\n\n      heftEntryPoint = path.join(heftFolder, 'lib', 'start.js');\n      if (!fs.existsSync(heftEntryPoint)) {\n        throw new Error('Unable to find Heft entry point: ' + heftEntryPoint);\n      }\n      console.log(`Using local Heft from ${heftFolder}`);\n      console.log();\n    } catch (error) {\n      throw new Error('Error probing for local Heft version: ' + (error as Error).message);\n    }\n\n    require(heftEntryPoint);\n\n    // We found and successfully invoked the local Heft\n    return true;\n  }\n\n  // We couldn't find the package folder\n  return false;\n}\n\nif (!tryStartLocalHeft()) {\n  // A project Heft dependency was not found, so launch the unmanaged version.\n  require('./start.js');\n}\n"]}