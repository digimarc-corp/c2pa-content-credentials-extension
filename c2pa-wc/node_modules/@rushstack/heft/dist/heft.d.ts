import { AsyncParallelHook } from 'tapable';
import { AsyncSeriesBailHook } from 'tapable';
import { AsyncSeriesHook } from 'tapable';
import { AsyncSeriesWaterfallHook } from 'tapable';
import { CommandLineAction } from '@rushstack/ts-command-line';
import { CommandLineFlagParameter } from '@rushstack/ts-command-line';
import { CommandLineIntegerParameter } from '@rushstack/ts-command-line';
import { CommandLineParser } from '@rushstack/ts-command-line';
import { CommandLineStringListParameter } from '@rushstack/ts-command-line';
import { CommandLineStringParameter } from '@rushstack/ts-command-line';
import { FileLocationStyle } from '@rushstack/node-core-library';
import { IBaseCommandLineDefinition } from '@rushstack/ts-command-line';
import { ICommandLineChoiceDefinition } from '@rushstack/ts-command-line';
import { ICommandLineChoiceListDefinition } from '@rushstack/ts-command-line';
import { ICommandLineFlagDefinition } from '@rushstack/ts-command-line';
import { ICommandLineIntegerDefinition } from '@rushstack/ts-command-line';
import { ICommandLineStringDefinition } from '@rushstack/ts-command-line';
import { ICommandLineStringListDefinition } from '@rushstack/ts-command-line';
import { IFileErrorFormattingOptions } from '@rushstack/node-core-library';
import { IPackageJson } from '@rushstack/node-core-library';
import { ITerminal } from '@rushstack/node-core-library';
import { ITerminalProvider } from '@rushstack/node-core-library';
import { JsonSchema } from '@rushstack/node-core-library';
import { RigConfig } from '@rushstack/rig-package';
import { SyncHook } from 'tapable';
import { Terminal } from '@rushstack/node-core-library';

declare class BuildStage extends StageBase<BuildStageHooks, IBuildStageProperties, IBuildStageOptions> {
    constructor(heftConfiguration: HeftConfiguration, loggingManager: LoggingManager);
    static defineStageStandardParameters(action: CommandLineAction): IBuildStageStandardParameters;
    static getOptionsFromStandardParameters(standardParameters: IBuildStageStandardParameters): Omit<IBuildStageOptions, 'watchMode' | 'serveMode'>;
    protected getDefaultStagePropertiesAsync(options: IBuildStageOptions): Promise<IBuildStageProperties>;
    protected executeInnerAsync(): Promise<void>;
    private _runSubstageWithLoggingAsync;
}

/**
 * @public
 */
export declare class BuildStageHooks extends StageHooksBase<IBuildStageProperties> {
    readonly preCompile: SyncHook<IPreCompileSubstage>;
    readonly compile: SyncHook<ICompileSubstage>;
    readonly bundle: SyncHook<IBundleSubstage>;
    readonly postBuild: SyncHook<IPostBuildSubstage>;
}

/**
 * @public
 */
export declare class BuildSubstageHooksBase {
    readonly run: AsyncParallelHook;
}

/**
 * @public
 */
export declare class BundleSubstageHooks extends BuildSubstageHooksBase {
    readonly configureWebpack: AsyncSeriesWaterfallHook<unknown>;
    readonly afterConfigureWebpack: AsyncSeriesHook;
}

declare class CleanStage extends StageBase<CleanStageHooks, ICleanStageProperties, ICleanStageOptions> {
    constructor(heftConfiguration: HeftConfiguration, loggingManager: LoggingManager);
    protected getDefaultStagePropertiesAsync(options: ICleanStageOptions): Promise<ICleanStageProperties>;
    protected executeInnerAsync(): Promise<void>;
}

/**
 * @public
 */
export declare class CleanStageHooks extends StageHooksBase<ICleanStageProperties> {
    readonly run: AsyncParallelHook;
}

/**
 * @public
 */
export declare class CompileSubstageHooks extends BuildSubstageHooksBase {
    /**
     * The `afterCompile` event is fired exactly once, after the "compile" stage completes its first operation.
     * The "bundle" stage will not begin until all event handlers have resolved their promises.  The behavior
     * of this event is the same in watch mode and non-watch mode.
     */
    readonly afterCompile: AsyncParallelHook;
    /**
     * The `afterRecompile` event is only used in watch mode.  It fires whenever the compiler's outputs have
     * been rebuilt.  The initial compilation fires the `afterCompile` event only, and then all subsequent iterations
     * fire the `afterRecompile` event only. Heft does not wait for the `afterRecompile` promises to resolve.
     */
    readonly afterRecompile: AsyncParallelHook;
}

/** @beta */
export declare type CustomActionParameterType = string | boolean | number | ReadonlyArray<string> | undefined;

/**
 * @beta
 * Command line utilities provided for Heft plugin developers.
 */
export declare class HeftCommandLine {
    private readonly _commandLineParser;
    private readonly _terminal;
    /**
     * @internal
     */
    constructor(commandLineParser: CommandLineParser, terminal: ITerminal);
    /**
     * Utility method used by Heft plugins to register a choice type parameter.
     */
    registerChoiceParameter(options: IHeftRegisterParameterOptions<ICommandLineChoiceDefinition>): IHeftChoiceParameter;
    /**
     * Utility method used by Heft plugins to register a choiceList type parameter.
     */
    registerChoiceListParameter(options: IHeftRegisterParameterOptions<ICommandLineChoiceListDefinition>): IHeftChoiceListParameter;
    /**
     * Utility method used by Heft plugins to register a flag type parameter.
     */
    registerFlagParameter(options: IHeftRegisterParameterOptions<ICommandLineFlagDefinition>): IHeftFlagParameter;
    /**
     * Utility method used by Heft plugins to register an integer type parameter.
     */
    registerIntegerParameter(options: IHeftRegisterParameterOptions<ICommandLineIntegerDefinition>): IHeftIntegerParameter;
    /**
     * Utility method used by Heft plugins to register a string type parameter.
     */
    registerStringParameter(options: IHeftRegisterParameterOptions<ICommandLineStringDefinition>): IHeftStringParameter;
    /**
     * Utility method used by Heft plugins to register a stringList type parameter.
     */
    registerStringListParameter(options: IHeftRegisterParameterOptions<ICommandLineStringListDefinition>): IHeftStringListParameter;
    private _registerParameter;
    private _getActions;
    private _verifyUniqueParameterName;
    private _verifyParametersProcessed;
}

/**
 * @public
 */
export declare class HeftConfiguration {
    private _buildFolder;
    private _projectHeftDataFolder;
    private _projectConfigFolder;
    private _buildCacheFolder;
    private _rigConfig;
    private _globalTerminal;
    private _terminalProvider;
    /**
     * Project build folder. This is the folder containing the project's package.json file.
     */
    get buildFolder(): string;
    /**
     * The path to the project's ".heft" folder.
     */
    get projectHeftDataFolder(): string;
    /**
     * The path to the project's "config" folder.
     */
    get projectConfigFolder(): string;
    /**
     * The project's build cache folder.
     *
     * This folder exists at \<project root\>/.heft/build-cache. TypeScript's output
     * goes into this folder and then is either copied or linked to the final output folder
     */
    get buildCacheFolder(): string;
    /**
     * The rig.json configuration for this project, if present.
     */
    get rigConfig(): RigConfig;
    /**
     * Terminal instance to facilitate logging.
     */
    get globalTerminal(): Terminal;
    /**
     * Terminal provider for the provided terminal.
     */
    get terminalProvider(): ITerminalProvider;
    /**
     * The Heft tool's package.json
     */
    get heftPackageJson(): IPackageJson;
    /**
     * The package.json of the project being built
     */
    get projectPackageJson(): IPackageJson;
    private constructor();
    /**
     * Performs the search for rig.json and initializes the `HeftConfiguration.rigConfig` object.
     * @internal
     */
    _checkForRigAsync(): Promise<void>;
    /**
     * @internal
     */
    static initialize(options: _IHeftConfigurationInitializationOptions): HeftConfiguration;
}

/** @internal */
export declare class _HeftLifecycleHooks {
    toolStart: AsyncParallelHook;
}

/**
 * @public
 */
export declare class HeftSession {
    private readonly _loggingManager;
    private readonly _options;
    private readonly _getIsDebugMode;
    readonly hooks: IHeftSessionHooks;
    /**
     * @internal
     */
    readonly metricsCollector: _MetricsCollector;
    /**
     * If set to true, the build is running with the --debug flag
     */
    get debugMode(): boolean;
    /** @beta */
    readonly registerAction: RegisterAction;
    /**
     * @beta
     * {@inheritDoc HeftCommandLine}
     */
    readonly commandLine: HeftCommandLine;
    /**
     * Call this function to receive a callback with the plugin if and after the specified plugin
     * has been applied. This is used to tap hooks on another plugin.
     *
     * @beta
     */
    readonly requestAccessToPluginByName: RequestAccessToPluginByNameCallback;
    /**
     * @internal
     */
    constructor(options: IHeftSessionOptions, internalSessionOptions: IInternalHeftSessionOptions);
    /**
     * Call this function to request a logger with the specified name.
     */
    requestScopedLogger(loggerName: string): ScopedLogger;
}

/**
 * @public
 */
export declare interface IBuildStageContext extends IStageContext<BuildStageHooks, IBuildStageProperties> {
}

declare interface IBuildStageOptions {
    production: boolean;
    lite: boolean;
    locales?: ReadonlyArray<string>;
    maxOldSpaceSize?: string;
    watchMode: boolean;
    serveMode: boolean;
    typescriptMaxWriteParallelism?: number;
}

/**
 * @public
 */
export declare interface IBuildStageProperties {
    production: boolean;
    lite: boolean;
    locales?: ReadonlyArray<string>;
    maxOldSpaceSize?: string;
    watchMode: boolean;
    serveMode: boolean;
    webpackStats?: unknown;
    /**
     * @beta
     */
    isTypeScriptProject?: boolean;
    /**
     * @beta
     */
    emitFolderNameForTests?: string;
    /**
     * @beta
     */
    emitExtensionForTests?: '.js' | '.cjs' | '.mjs';
}

declare interface IBuildStageStandardParameters {
    productionFlag: CommandLineFlagParameter;
    localesParameter: CommandLineStringListParameter;
    liteFlag: CommandLineFlagParameter;
    typescriptMaxWriteParallelismParameter: CommandLineIntegerParameter;
    maxOldSpaceSizeParameter: CommandLineStringParameter;
}

/**
 * @public
 */
export declare interface IBuildSubstage<TBuildSubstageHooks extends BuildSubstageHooksBase, TBuildSubstageProperties extends object> {
    hooks: TBuildSubstageHooks;
    properties: TBuildSubstageProperties;
}

/**
 * @public
 */
export declare interface IBundleSubstage extends IBuildSubstage<BundleSubstageHooks, IBundleSubstageProperties> {
}

/**
 * @public
 */
export declare interface IBundleSubstageProperties {
    /**
     * If webpack is used, this will be set to the version of the webpack package
     */
    webpackVersion?: string | undefined;
    /**
     * If webpack is used, this will be set to the version of the webpack-dev-server package
     */
    webpackDevServerVersion?: string | undefined;
    /**
     * The configuration used by the Webpack plugin. This must be populated
     * for Webpack to run. If webpackConfigFilePath is specified,
     * this will be populated automatically with the exports of the
     * config file referenced in that property.
     */
    webpackConfiguration?: unknown;
}

/**
 * @public
 */
export declare interface ICleanStageContext extends IStageContext<CleanStageHooks, ICleanStageProperties> {
}

declare interface ICleanStageOptions {
    deleteCache?: boolean;
}

/**
 * @public
 */
export declare interface ICleanStageProperties {
    deleteCache: boolean;
    pathsToDelete: Set<string>;
}

/**
 * @public
 */
export declare interface ICompileSubstage extends IBuildSubstage<CompileSubstageHooks, ICompileSubstageProperties> {
}

/**
 * @public
 */
export declare interface ICompileSubstageProperties {
    typescriptMaxWriteParallelism: number | undefined;
}

/** @beta */
export declare interface ICustomActionOptions<TParameters> {
    actionName: string;
    documentation: string;
    summary?: string;
    parameters?: {
        [K in keyof TParameters]: ICustomActionParameter<TParameters[K]>;
    };
    callback: (parameters: TParameters) => void | Promise<void>;
}

/** @beta */
export declare type ICustomActionParameter<TParameter> = TParameter extends boolean ? ICustomActionParameterFlag : TParameter extends number ? ICustomActionParameterInteger : TParameter extends string ? ICustomActionParameterString : TParameter extends ReadonlyArray<string> ? ICustomActionParameterStringList : never;

/** @beta */
export declare interface ICustomActionParameterBase<CustomActionParameterType> {
    kind: 'flag' | 'integer' | 'string' | 'stringList';
    parameterLongName: string;
    description: string;
}

/** @beta */
export declare interface ICustomActionParameterFlag extends ICustomActionParameterBase<boolean> {
    kind: 'flag';
}

/** @beta */
export declare interface ICustomActionParameterInteger extends ICustomActionParameterBase<number> {
    kind: 'integer';
}

/** @beta */
export declare interface ICustomActionParameterString extends ICustomActionParameterBase<string> {
    kind: 'string';
}

/** @beta */
export declare interface ICustomActionParameterStringList extends ICustomActionParameterBase<ReadonlyArray<string>> {
    kind: 'stringList';
}

/**
 * The base action configuration that all custom action configuration files
 * should inherit from.
 *
 * @public
 */
export declare interface IHeftActionConfiguration {
}

/**
 * Options to be used when retrieving the action configuration.
 *
 * @public
 */
export declare interface IHeftActionConfigurationOptions {
    /**
     * Whether or not arrays should be merged across Heft action configuration files.
     */
    mergeArrays?: boolean;
}

/**
 * @beta
 * The base set of utility values provided in every object returned when registering a parameter.
 */
export declare interface IHeftBaseParameter<TValue, TCommandLineDefinition extends IBaseCommandLineDefinition> {
    /**
     * The value specified on the command line for this parameter.
     */
    readonly value?: TValue;
    /**
     * If true, then the user has invoked Heft with a command line action that supports this parameter
     * (as defined by the {@link IParameterAssociatedActionNames.associatedActionNames} option).
     *
     * @remarks
     * For example, if `build` is one of the associated action names for `--my-integer-parameter`,
     * then `actionAssociated` will be true if the user invokes `heft build`.
     *
     * To test whether the parameter was actually included (e.g. `heft build --my-integer-parameter 123`),
     * verify the {@link IHeftBaseParameter.value} property is not `undefined`.
     */
    readonly actionAssociated: boolean;
    /**
     * The options {@link IHeftRegisterParameterOptions} used to create and register the parameter with
     * a Heft command line action.
     */
    readonly definition: IHeftRegisterParameterOptions<TCommandLineDefinition>;
}

/**
 * @beta
 * The object returned when registering a choiceList type parameter.
 */
export declare type IHeftChoiceListParameter = IHeftBaseParameter<readonly string[], ICommandLineChoiceListDefinition>;

/**
 * @beta
 * The object returned when registering a choice type parameter.
 */
export declare type IHeftChoiceParameter = IHeftBaseParameter<string, ICommandLineChoiceDefinition>;

/**
 * @internal
 */
export declare interface _IHeftConfigurationInitializationOptions {
    /**
     * The working directory the tool was executed in.
     */
    cwd: string;
    /**
     * Terminal instance to facilitate logging.
     */
    terminalProvider: ITerminalProvider;
}

/**
 * @beta
 * The object returned when registering a flag type parameter.
 */
export declare type IHeftFlagParameter = IHeftBaseParameter<boolean, ICommandLineFlagDefinition>;

/**
 * @beta
 * The object returned when registering an integer type parameter.
 */
export declare type IHeftIntegerParameter = IHeftBaseParameter<number, ICommandLineIntegerDefinition>;

/** @internal */
export declare interface _IHeftLifecycle {
    hooks: _HeftLifecycleHooks;
}

/**
 * @public
 */
export declare interface IHeftPlugin<TOptions = void> {
    readonly pluginName: string;
    readonly optionsSchema?: JsonSchema;
    readonly accessor?: object;
    apply(heftSession: HeftSession, heftConfiguration: HeftConfiguration, options?: TOptions): void;
}

/**
 * @beta
 * The options object provided to the command line parser when registering a parameter
 * in addition to the action names used to associate the parameter with.
 */
export declare type IHeftRegisterParameterOptions<TCommandLineDefinition extends IBaseCommandLineDefinition> = TCommandLineDefinition & IParameterAssociatedActionNames;

/**
 * @public
 */
export declare interface IHeftSessionHooks {
    metricsCollector: MetricsCollectorHooks;
    /** @internal */
    heftLifecycle: SyncHook<_IHeftLifecycle>;
    build: SyncHook<IBuildStageContext>;
    clean: SyncHook<ICleanStageContext>;
    test: SyncHook<ITestStageContext>;
}

declare interface IHeftSessionOptions {
    plugin: IHeftPlugin;
    /**
     * @beta
     */
    requestAccessToPluginByName: RequestAccessToPluginByNameCallback;
}

/**
 * @beta
 * The object returned when registering a stringList type parameter.
 */
export declare type IHeftStringListParameter = IHeftBaseParameter<readonly string[], ICommandLineStringListDefinition>;

/**
 * @beta
 * The object returned when registering a string type parameter.
 */
export declare type IHeftStringParameter = IHeftBaseParameter<string, ICommandLineStringDefinition>;

/**
 * @internal
 */
declare interface IInternalHeftSessionOptions {
    heftLifecycleHook: SyncHook<_IHeftLifecycle>;
    buildStage: BuildStage;
    cleanStage: CleanStage;
    testStage: TestStage;
    metricsCollector: _MetricsCollector;
    loggingManager: LoggingManager;
    getIsDebugMode(): boolean;
    registerAction: RegisterAction;
    commandLine: HeftCommandLine;
}

declare interface ILoggingManagerOptions {
    terminalProvider: ITerminalProvider;
}

/**
 * @public
 */
export declare interface IMetricsData {
    /**
     * The command that was executed.
     */
    command: string;
    /**
     * Whether or not the command ran into errors
     */
    encounteredError?: boolean;
    /**
     * The amount of time the command took to execute, in milliseconds.
     */
    taskTotalExecutionMs: number;
    /**
     * The name of the operating system provided by NodeJS.
     */
    machineOs: string;
    /**
     * The processor's architecture.
     */
    machineArch: string;
    /**
     * The number of processor cores.
     */
    machineCores: number;
    /**
     * The processor's model name.
     */
    machineProcessor: string;
    /**
     * The total amount of memory the machine has, in megabytes.
     */
    machineTotalMemoryMB: number;
    /**
     * A map of commandline parameter names to their effective values
     */
    commandParameters: Record<string, string>;
}

/**
 * @beta
 * The configuration interface for associating a parameter definition with a Heft
 * command line action in {@link IHeftRegisterParameterOptions}.
 */
export declare interface IParameterAssociatedActionNames {
    /**
     * A string list of one or more action names to associate the parameter with.
     */
    associatedActionNames: string[];
}

/**
 * @internal
 */
export declare interface _IPerformanceData {
    taskTotalExecutionMs: number;
    encounteredError?: boolean;
}

/**
 * @public
 */
export declare interface IPostBuildSubstage extends IBuildSubstage<BuildSubstageHooksBase, {}> {
}

/**
 * @public
 */
export declare interface IPreCompileSubstage extends IBuildSubstage<BuildSubstageHooksBase, {}> {
}

/**
 * Options provided to scripts that are run using the RunScriptPlugin.
 *
 * @beta
 */
export declare interface IRunScriptOptions<TStageProperties> {
    scopedLogger: ScopedLogger;
    heftConfiguration: HeftConfiguration;
    debugMode: boolean;
    properties: TStageProperties;
    scriptOptions: Record<string, any>;
}

/**
 * @public
 */
export declare interface IScopedLogger {
    readonly terminal: Terminal;
    /**
     * Call this function to emit an error to the heft runtime.
     */
    emitError(error: Error): void;
    /**
     * Call this function to emit an warning to the heft runtime.
     */
    emitWarning(warning: Error): void;
}

declare interface IScopedLoggerOptions {
    requestingPlugin: IHeftPlugin;
    loggerName: string;
    terminalProvider: ITerminalProvider;
    getShouldPrintStacks: () => boolean;
    errorHasBeenEmittedCallback: () => void;
}

/**
 * @public
 */
export declare interface IStageContext<TStageHooks extends StageHooksBase<TStageProperties>, TStageProperties extends object> {
    hooks: TStageHooks;
    properties: TStageProperties;
}

/**
 * @public
 */
export declare interface ITestStageContext extends IStageContext<TestStageHooks, ITestStageProperties> {
}

declare interface ITestStageOptions {
    watchMode: boolean;
}

/**
 * @public
 */
export declare interface ITestStageProperties {
    watchMode: boolean;
}

declare class LoggingManager {
    private _options;
    private _scopedLoggers;
    private _shouldPrintStacks;
    private _hasAnyErrors;
    get errorsHaveBeenEmitted(): boolean;
    constructor(options: ILoggingManagerOptions);
    enablePrintStacks(): void;
    requestScopedLogger(plugin: IHeftPlugin, loggerName: string): ScopedLogger;
    getErrorStrings(fileLocationStyle?: FileLocationStyle): string[];
    getWarningStrings(fileErrorFormat?: FileLocationStyle): string[];
    static getErrorMessage(error: Error, options?: IFileErrorFormattingOptions): string;
}

/**
 * @internal
 * A simple performance metrics collector. A plugin is required to pipe data anywhere.
 */
export declare class _MetricsCollector {
    readonly hooks: MetricsCollectorHooks;
    private _hasBeenTornDown;
    private _startTimeMs;
    /**
     * Start metrics log timer.
     */
    setStartTime(): void;
    /**
     * Record metrics to the installed plugin(s).
     *
     * @param command - Describe the user command, e.g. `start` or `build`
     * @param parameterMap - Optional map of parameters to their values
     * @param performanceData - Optional performance data
     */
    record(command: string, performanceData?: Partial<_IPerformanceData>, parameters?: Record<string, string>): void;
    /**
     * Flushes all pending logged metrics.
     */
    flushAsync(): Promise<void>;
    /**
     * Flushes all pending logged metrics and closes the MetricsCollector instance.
     */
    flushAndTeardownAsync(): Promise<void>;
}

/**
 * Tap these hooks to record build metrics, to a file, for example.
 *
 * @public
 */
export declare class MetricsCollectorHooks {
    /**
     * This hook is called when a metric is recorded.
     */
    recordMetric: SyncHook<string, IMetricsData>;
    /**
     * This hook is called when collected metrics should be flushed
     */
    flush: AsyncParallelHook;
    /**
     * This hook is called when collected metrics should be flushed and no more metrics will be collected.
     */
    flushAndTeardown: AsyncParallelHook;
}

/** @beta */
export declare type RegisterAction = <TParameters>(action: ICustomActionOptions<TParameters>) => void;

/**
 * @beta
 */
export declare type RequestAccessToPluginByNameCallback = (pluginToAccessName: string, pluginApply: (pluginAccessor: object) => void) => void;

/**
 * @public
 */
export declare class ScopedLogger implements IScopedLogger {
    private readonly _options;
    private readonly _errors;
    private readonly _warnings;
    private get _shouldPrintStacks();
    get errors(): ReadonlyArray<Error>;
    get warnings(): ReadonlyArray<Error>;
    /**
     * @internal
     */
    readonly _requestingPlugin: IHeftPlugin;
    readonly loggerName: string;
    readonly terminalProvider: ITerminalProvider;
    readonly terminal: Terminal;
    /**
     * @internal
     */
    constructor(options: IScopedLoggerOptions);
    /**
     * {@inheritdoc IScopedLogger.emitError}
     */
    emitError(error: Error): void;
    /**
     * {@inheritdoc IScopedLogger.emitWarning}
     */
    emitWarning(warning: Error): void;
}

declare abstract class StageBase<TStageHooks extends StageHooksBase<TStageProperties>, TStageProperties extends object, TStageOptions> {
    readonly stageInitializationHook: SyncHook<IStageContext<TStageHooks, TStageProperties>>;
    protected readonly heftConfiguration: HeftConfiguration;
    protected readonly loggingManager: LoggingManager;
    protected readonly globalTerminal: ITerminal;
    protected stageOptions: TStageOptions;
    protected stageProperties: TStageProperties;
    protected stageHooks: TStageHooks;
    private readonly _innerHooksType;
    constructor(heftConfiguration: HeftConfiguration, loggingManager: LoggingManager, innerHooksType: new () => TStageHooks);
    initializeAsync(stageOptions: TStageOptions): Promise<void>;
    executeAsync(): Promise<void>;
    protected abstract getDefaultStagePropertiesAsync(options: TStageOptions): Promise<TStageProperties>;
    protected abstract executeInnerAsync(): Promise<void>;
}

/**
 * @public
 */
export declare abstract class StageHooksBase<TStageProperties extends object> {
    /**
     * This hook allows the stage's execution to be completely overridden. Only the last-registered plugin
     * with an override hook provided applies.
     *
     * @beta
     */
    readonly overrideStage: AsyncSeriesBailHook<TStageProperties>;
    readonly loadStageConfiguration: AsyncSeriesHook;
    readonly afterLoadStageConfiguration: AsyncSeriesHook;
}

declare class TestStage extends StageBase<TestStageHooks, ITestStageProperties, ITestStageOptions> {
    constructor(heftConfiguration: HeftConfiguration, loggingManager: LoggingManager);
    protected getDefaultStagePropertiesAsync(options: ITestStageOptions): Promise<ITestStageProperties>;
    protected executeInnerAsync(): Promise<void>;
}

/**
 * @public
 */
export declare class TestStageHooks extends StageHooksBase<ITestStageProperties> {
    readonly run: AsyncParallelHook;
    readonly configureTest: AsyncSeriesHook;
}

export { }
