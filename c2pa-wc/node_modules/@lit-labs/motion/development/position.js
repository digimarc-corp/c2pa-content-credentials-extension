import { nothing } from 'lit/html.js';
import { directive, PartType } from 'lit/directive.js';
import { AsyncDirective } from 'lit/async-directive.js';
const positionedPoints = ['top', 'right', 'bottom', 'left'];
export class Position extends AsyncDirective {
    constructor(part) {
        super(part);
        if (part.type !== PartType.ELEMENT) {
            throw new Error('The `position` directive must be used in attribute position.');
        }
    }
    render(_targetCallbackOrRef, _positions) {
        return nothing;
    }
    update(part, [target, positions]) {
        var _a;
        if (this._host === undefined) {
            this._host = (_a = part.options) === null || _a === void 0 ? void 0 : _a.host;
            this._host.addController(this);
        }
        this._element = part.element;
        this._targetCallbackOrRef = target;
        this._positions = positions !== null && positions !== void 0 ? positions : ['left', 'top', 'width', 'height'];
        return this.render(target, positions);
    }
    hostUpdated() {
        this._position();
    }
    _position() {
        var _a, _b;
        const target = typeof this._targetCallbackOrRef === 'function'
            ? this._targetCallbackOrRef()
            : (_a = this._targetCallbackOrRef) === null || _a === void 0 ? void 0 : _a.value;
        const parent = target.offsetParent;
        if (target === undefined || !parent) {
            return;
        }
        const tr = target.getBoundingClientRect();
        const pr = parent.getBoundingClientRect();
        (_b = this._positions) === null || _b === void 0 ? void 0 : _b.forEach((p) => {
            const x = positionedPoints.includes(p) ? tr[p] - pr[p] : tr[p];
            this._element.style[p] = `${x}px`;
        });
    }
}
/**
 * Positions and sizes the element on which the `position()` directive is used
 * relative to the given target element.
 */
export const position = directive(Position);
//# sourceMappingURL=position.js.map